## Shell及权限理解

本文将介绍Shell是什么以及Linux中的权限。

可以想一想在我们使用计算机的过程中，我们使用图形化界面或者命令行操作与计算机进行交互，是直接与内核进行交互吗？如果是那内核的接口开放出来想一想会有哪些问题呢？

### shell命令以及运行原理

---

Linux严格意义上说的是一个操作系统，我们称之为“核心（kernel）“ ，但我们一般用户，不能直接使用kernel。而是通过kernel的“外壳”程序，也就是所谓的shell，来与kernel沟通。如何理解？为什么不能直接使用kernel？

从技术角度，Shell的最简单定义：**命令行解释器（command Interpreter）**主要包含：

> 将使用者的命令翻译给核心（kernel）处理。
>
> 内核处理命令后，将内核的处理结果翻译给使用者。

![image-20220820201826908](https://pic.xinsong.xyz/img/202208202018939.png)

**对比windows GUI**，我们操作windows 不是直接操作windows内核，而是通过图形接口，点击，从而完成我们的操作（比如进入D盘的操作，我们通常是双击D盘盘符.或者运行起来一个应用程序）。

Windows中，shell就是图形化界面操作，在Linux中，shell就是命令行操作。

shell 对于Linux，有相同的作用，主要是对我们的指令进行解析，解析指令给Linux内核。反馈结果在通过内核运行出结果返回给shell，通过shell解析返回给用户。

> 帮助理解：如果说你是一个闷骚且害羞的程序员，那shell就像媒婆，操作系统内核就是你们村头漂亮的且有让你心动的MM小花。你看上了小花，但是有不好意思直接表白，那就让你你家人找媒婆帮你提亲，所有的事情你都直接跟媒婆沟通，由媒婆转达你的意思给小花，而我们找到媒婆姓王，所以我们叫她王婆，它对应我们常使用的bash。

**作用**：

1. 降低OS的操作成本（最大意义）
2. 保护kernel，不将OS kernel直接暴露给用户。

**centos 7 常用的命令行解释器（shell）叫做bash**。

shell是这一类命令行解释器程序的总称，而bash是其中的一员。



## Linux权限的概念

**Linux下有两种用户：超级用户（root）、普通用户**。

* 超级用户（root）：可以再linux系统下做任何事情，不受限制，只有一个。
* 普通用户：在linux下做有限的事情，权限受到约束，可以由很多个。
* 超级用户的命令提示符是“#”，普通用户的命令提示符是“$”。

查看当前用户：`whoami`

root拥有超级权限，不受规则约束，权限仅仅约束普通用户。

**切换用户**

**命令**：su [用户名]

**功能**：切换用户。

例如，要从root用户切换到普通用户user，则使用 su user。 要从普通用户user切换到root用户则使用 su root（root可以省略），此时系统会提示输入root用户密码的口令。



`su -`也可以切换至root，但是与`su root`却有区别，使用`su root`没有登录提示符，而`su -`有登陆提示符。

先来明白**两个概念**：

**登录shell和非登录shell**

登录shell：是需要用户名、密码登录后才能进入的shell（或者通过”–login”选项生成的shell）。

非登录shell：当然就不需要输入用户名和密码即可打开的Shell，例如：直接命令“bash”就是打开一个新的非登录shell，在Gnome或KDE中打开一个终端（terminal）窗口程序也是一个非登录shell。

**执行exit命令，退出一个shell（登录或非登录shell都可以退出）**

**执行logout命令，退出登录shell（不能退出非登录shell）。**

**看看下面**：

使用 su -

```shell
Last login: Sat Aug 20 20:33:41 2022 from 60.255.33.159
[sx@VM-4-9-centos ~]$ whoami
sx
[sx@VM-4-9-centos ~]$ su -# 登录root
Password: 
Last login: Sat Aug 20 20:34:07 CST 2022 on pts/0
[root@VM-4-9-centos ~]# whoami
root
[root@VM-4-9-centos ~]# logout
[sx@VM-4-9-centos ~]$ whoami
sx
```

使用 su root

```shell
Last login: Sat Aug 20 20:38:30 2022 from 60.255.33.159
[sx@VM-4-9-centos ~]$ whoami
sx
[sx@VM-4-9-centos ~]$ su root
Password: 
[root@VM-4-9-centos sx]# whoami
root
[root@VM-4-9-centos sx]# logout
bash: logout: not login shell: use `exit'
```

可以看到打开非登录shell时不会有登陆提示符，因此无法使用logout登出shell，而exit无论是登录shell还是非登录shell都可以退出。



**小Tips**：

1. root用户密码和普通用户密码不要设置为同一个！

2. 从root用户可以切换至任何用户，一定要防止root用户泄露！
3. 从普通用户切换至另一个用户，需要的是要切换的用户的密码。



### 什么是权限

**权限 = 人 + 事务属性**

在现实生活中，法律规定了哪些人能做什么事情，哪些人不能做什么事情，所以说判断一个人是否具备相应权限不仅仅是由人决定，还与具体做什么事情有关。

**举个例子**：我能不能在水吧吃顿饭？就涉及到两方面问题：

1.  我能进去这个水吧吗？
2. 水吧有饭给我吃吗？

如果都满足，那么才说明我可以在水吧吃顿饭，也就是说我有在水吧吃饭的这个权限。



**linux下的权限**

我们之前说过linux下皆文件，那么用户对linux进行操作，其实都是对文件进行操作，在对文件操作的过程中，就涉及到用户权限的问题，也就是用户对于文件是否具有相应权限。

这个权限问题就和上面我能不能在水吧吃顿饭的问题是一样的。

**linux用户是否对某个文件具有相应权限，其实是**：

1. 用户能否对这个文件执行相应操作
2. 文件是否具有用户想要对文件操作的属性

判断一个用户对于某个文件是否具有相应权限，也必须满足两个条件，只要有一个不满足，那么此用户就不具备相应权限。



### Linux权限管理

---

首先我们想想，在linux中权限的管理是通过用户还是通过文件来管理的？

类比到现实世界，法律能不能将每一个人对每一件事的行为准则都规范一下并写到书里呢？显然是不现实的的，全世界那么多人，那得多麻烦？通常法律是将人身份进行分类，对某一件事物上根据人的身份类别不同对人加以不同的约束，然后针对每个事物规定 某身份的人对某事物能做什么。

**举个例子**：医院看病，军人优先，这就是一种权限。那么可以看到在医院看病这件事上，军人有优先的属性，那是不是军人对于所有事物都有此优先权限呢？那显然不是的，只有规定了军人优先的事物，军人才会对该事物有优先权。军人这个身份仅仅是在某些或者某一个事物上具有相应权限。并且军人这个身份不是一成不变的，对于不同的事物同一个人有不同的身份，就比如一个军人可以是母亲的儿子，妻子的丈夫，等等身份。

其实linux也是如此，它无法具体到每个用户对每个文件的权限（文件可太多了，用户也理论上可以无限多），也是通过对用户进行身份分类，再通过身份判断是否对一个文件具备相应权限，同一个用户对于不同的文件也可以拥有不同的身份，针对每一个文件规定 某文件某身份的人能有有什么权限。



#### 一个文件访问者的分类（相对于文件的身份）

* **文件和文件目录的所有者**：u---User（owner）

* **文件和文件目录的所有者所在的组的用户**：g---Group

* **其它用户**：o---Others （除了owner和group之外的）



**一个问题**：linux中的用户有root和普通用户，那这里又冒出来user、group、others这些，那么【root、普通用户】和【owner、group、others】它们之间相互冲突吗？

**答案是否定的**，它们不会冲突，反而会有相互补充的作用。因为【owner、group、others】是相对于一个文件来说它有这样的用户分类（根据身份分类），而【root、普通用户】并不是针对某个文件，而是此计算机的使用者。是为了方便对文件权限的管理，才引申出【owner、group、others】这样的用户分类。

设想下，如果如果没有【owner、group、others】这样的相对于一个文件的用户分类的概念，那当我们想呈现一个文件的权限信息时，是不是就要显示出对每一个用户（【root、普通用户】）的权限呢？这样做显然太麻烦了，如果用户很多，在修改权限时也非常的麻烦。因此为了解决这个问题，在呈现一个文件的权限信息时，就新增了一个抽象用户概念【owner、group、others】。这样我们就不需要将每一个用户的权限信息逐一呈现出来了。

下图即为【owner、group、others】充当“**代理人**”的过程，可以表示什么人对该文件有什么权限。

![image-20220829202457848](https://pic.xinsong.xyz/img/202208292024896.png)

可以看到无论你多少个用户，使用这个机制，对于一个文件来说，需要管理的仅仅就只有“三个用户”而已，当然这里的“用户”不是具体的用户，而更像是一种身份，相对于文件的身份！当我们想改变某个用户对这个文件的权限，只需要修改此用户相对于这个文件的身份即可，linux提供了将用户修改为owner和group的方法，虽然没有直接提供修改为other的方法，但是修改owner和group实际也就是对other进行了修改。

下图为直接呈现出用户和文件之间权限的过程，这样的方法如果user比较少，那么也没什么问题，可如果用户非常多，那这样的方式显然不利于我们的权限管理。

![image-20220829203042452](https://pic.xinsong.xyz/img/202208292030505.png)

#### 文件类型和访问权限（事物属性）

**使用ls -l命令查看文件属性**

```shell
[sx@VM-4-9-centos test]$ ls
test.tgz  test.txt
[sx@VM-4-9-centos test]$ ls -l
total 1460
-rw-rw-r-- 1 sx sx     193 Aug 20 16:01 test.tgz
-rw-rw-r-- 1 sx sx 1488895 Aug 19 18:10 test.txt
```

Linux系统不是以文件名后缀区分文件类型的（但Linux上的有些软件会区分后缀），而是如下图：



![image-20220820191844855](https://pic.xinsong.xyz/img/202208201918952.png)



#### 为什么linux中有所属组

我们在做开发时，不是一个人而是一个团队进行协作，也就是我们所写的代码不是只能被代码的编辑者（owner）看到的，而是我们这个团队的所属成员都能看到，也就是具有相应的读权限。

举个例子：

有A、B两个团队他们开发一个功能相似的软件，最终选择两个团队中较优秀的那一个。这两个团队都在同一个服务器上开发，但由于两个团队是竞争关系，因此他们都不希望对对方能够看到自己的源码。

于是：

A团队中的a写了一份代码Atesta.cpp

B团队中的b写了一份代码Btestb.cpp

因此a可以读写Atesta.cpp，b可以读写Btestb.cpp，但是由于他们不想被另一个团队查看，因此Atesta.cpp和Btestb.cpp文件other身份都是没有读权限的。

既然是团队协作协作开发，那必然会涉及到要查看团队中其他成员的代码。假如A团队中的另一个成员想要查看a写的Atesta.cpp，但是A团队其他成员相对于Atesta.cpp文件的身份就是other，是没有该文件的读权限的，这不就出问题了吗？因此为了能够让除owner身份之外的人，也能有该文件一定的权限，就产生了所属组并赋予新的权限值和other区分。



如果linux中没有所属组这个概念，而other又都没有读权限，那是不是这个A中的a写的代码和B中b写的代码都只能被他们自己看见呢？这显然不太合理。



**文件类型**

```txt
d：文件夹：也叫目录文件
-：普通文件：文本文件，源代码，可执行程序，第三方静态库
l：软链接（类似Windows的快捷方式），链接文件
b：块设备文件（例如硬盘、光驱等）
p：管道文件
c：字符设备文件（例如屏幕等串口设备）
s：套接口文件
```

**基本权限**

i.读（r/4）：Read对文件而言，具有读取文件内容的权限；对目录来说，具有浏览该目录信息的权限

ii.写（w/2）：Write对文件而言，具有修改文件内容的权限；对目录来说具有删除移动目录内文件的权限

iii.执行（x/1）：execute对文件而言，具有执行文件的权限；对目录来说，具有进入目录的权限

iv.“—”表示不具有该项权限



### 文件权限值的表示方法

**字符表示法**

![image-20220829192057745](https://pic.xinsong.xyz/img/202208291921846.png)

**八进制数值表示方法**

可以看到，【owner、group、others】对于某个文件的权限可分为三组。

一个“身份”（owner、group、other）对文件的权限分为一组，每一组中的每个位置权限含义都是确定的，分别表示 读、写、执行的权限，每一组对文件的权限都是由三个位置的状态表示的，而这每个位置都只有是和否两种状态，因此考虑用二进制表示。

第一个位置：r 或 -

第二个位置：w 或 -

第三个位置：x 或 -

我们使用二进制数进行替换，当位置为`–`的时候表示为0，位置不为`–`时表示为1，那么有三个位置，由三个二进制位就可以表示出每一种权限组合，那就是2^3^=8种，因此可以将二进制数转化为八进制数来表示权限。

这样通过3个八进制数就可以表示出三种身份的人对于某个文件的权限。

![image-20220829192121179](https://pic.xinsong.xyz/img/202208291921209.png)



### 文件访问权限相关设置方法

**chmod**

 **功能**：设置文件的访问权限

**格式**：chmod [参数] 权限 文件名

**常用选项**：

> R -> 递归修改目录文件的权限
>
> **说明**：只有文件的拥有者和root才可以改变文件的权限

①chmod命令权限值得格式

**用户表示符+-=权限字符**

> +:向权限范围增加权限代号所表示的权限
>
> -:向权限范围取消权限代号所表示的权限
>
> =:向权限范围赋予权限代号所表示的权限
>
> 用户符号：
>
> u：拥有者
>
> g：拥有者同组用
>
> o：其它用户
>
> a：所有用户

```shell
chmod u+w /home/abc.txt
chmod o-x /home/abc.txt
chmod g-r /home/abc.txt
chmod u-r,g-r dir
chmod a=rwx test.txt # 所有人权限都会变成rwx
```

②三位8进制数字

```shell
chmod 664 /home/abc.txt
chmod 640 /home/abc.txt
```



**chown**

 **功能**：修改文件的拥有者

**格式**：chown [参数] 用户名 文件名

实例：

```shell
chown user f1
chown -R user filegroup1
chown user myfile.txt 
```

**注意**：

普通用户，即使是此文件得拥有者，也无法修改文件的拥有者，道理也很简单，我们将东西自己的东西送给别人的时候这是一个双向的过程，你和被赠与者都需要同意，这件事情才是合法的。修改文件拥有者需要使用sudo以root身份执行该命令。

root拥有超级权限，不受规则约束，权限仅仅约束普通用户。



**chgrp**

 **功能**：修改文件或目录的所属组

**格式**：chgrp [参数] 用户组名 文件名

**常用选项**：-R 递归修改文件或目录的所属组

实例：

```shell
chown user myfile.txt  # 报错同上，需要sudo提升权限
```



**umask**

为何我们创建的目录的默认权限是775而普通文件是664？（不同系统可能有差异）

![image-20220902190335536](https://pic.xinsong.xyz/img/202209021903695.png)

这就要说到掩码了。

 **功能**：

查看或修改文件掩码

**理论上**：

新建文件夹默认权限=0666

新建目录默认权限=0777

但是默认权限不 != 最终权限

但实际上你所创建的文件和目录，看到的权限往往不是上面这个值。原因就是创建文件或目录的时候还受到umask的影响。假设默认权限是mask，则实际创建的出来的文件权限是: mask & (~umask) 或者 ((mask ^ umask) & umask) ^ (mask ^ umask)  ，一定注意运算先后顺序。

**格式**：umask 权限值

**说明**：将现有的存取权限减去权限掩码后，即可产生建立文件时预设权限。超级用户默认掩码值为0022，普通用户默认为0002。

实例：

```shell
umask 755
umask //查看
umask 044//设置
```

```
0   1   0   1  umask
1   0   0   1  mask

	最终结果
1   0   0   0
```

linux中最终权限 = 默认权限“去掉” umask中存在的权限，凡是在掩码中出现的权限都不应该在最终权限中出现！



**结论**：对文件的权限进行操作，这其实就是从人和文件属性这两方面进行操作，一方面我们修改文件面对不同身份【owner、group、other】时的属性，一方面我们修改用户相对于文件的身份，这样就能既简单又快捷的对用户对文件的权限进行管理了。

**小问题**：

想一想能不能用一个二进制数去表示一个用户对每一个文件的权限呢？

**答案是不行的！**文件可太多了，那得多少个二进制位！如果这样设计，我们也很难找到我们想要操作的那个文件权限对应的二进制位（们），这样做权限管理将会是一件很复杂的事情。



### 目录的权限

其实今天这个问题我们讲不透，简单说说吧。

我们都知道，linux下皆文件，目录也是文件。文件=文件内容+文件属性



那么进入一个目录需要什么权限？（面试题）

**答案是x**。至于为何是x，我目前认为目录是一个可执行程序（链接文件），用于进入目标目录文件。

```shell
[sx@VM-4-9-centos test]$ mkdir dir
[sx@VM-4-9-centos test]$ ll
total 8
drwxrwxr-x 2 sx sx 4096 Sep  2 22:07 dir
[sx@VM-4-9-centos test]$ chmod 660 dir
[sx@VM-4-9-centos test]$ ll
total 8
drw-rw---- 2 sx sx 4096 Sep  2 22:07 dir
[sx@VM-4-9-centos test]$ cd dir
-bash: cd: dir: Permission denied
```

如果没有目录的r权限，允许进入，允许到目录下创建文件，但无法查看目录文件列表（目录内容）

```shell
[sx@VM-4-9-centos test]$ ll
total 8
drwxrwxr-x 2 sx sx 4096 Sep  2 22:09 dir
[sx@VM-4-9-centos test]$ chmod u-r,g-r dir
[sx@VM-4-9-centos test]$ ll
total 8
d-wx-wxr-x 2 sx sx 4096 Sep  2 22:09 dir
[sx@VM-4-9-centos test]$ ls dir
ls: cannot open directory dir: Permission denied
```

如果没有目录的w权限，允许进入，能查看目录文件列表（目录内容），不能创建文件和删除文件，并且如果目录下有文件的话，此目录也是无法删除的，因为删除目录就会删除目录下文件，但无w权限无法删除目录下文件。

```shell
[sx@VM-4-9-centos test]$ chmod u-w,g-w dir
[sx@VM-4-9-centos test]$ ll
total 8
dr-xr-xr-x 2 sx sx 4096 Sep  2 22:20 dir
[sx@VM-4-9-centos test]$ cd dir
[sx@VM-4-9-centos dir]$ ls
test.c
[sx@VM-4-9-centos dir]$ rm -f test.c
rm: cannot remove ‘test.c’: Permission denied
[sx@VM-4-9-centos dir]$ cd ..
[sx@VM-4-9-centos test]$ rm -rf dir
rm: cannot remove ‘dir/test.c’: Permission denied
```

如果同时没有w和r权限，允许进入，但是不允许创建（删除）和查看目录下的文件列表（注意：不是文件内容！！！文件的内容，是否可以查看，由文件本身的权限决定！！）



目录内容：保存的部分文件属性，例如文件名。

如果没有目录的r权限，那么能不能进入访问目录下的文件呢？（目录下文件有访问权限）

```shell
[sx@VM-4-9-centos test]$ ll
total 8
d-wx-wxr-x 2 sx sx 4096 Sep  2 22:20 dir
[sx@VM-4-9-centos test]$ cd dir
[sx@VM-4-9-centos dir]$ ll
ls: cannot open directory .: Permission denied
[sx@VM-4-9-centos dir]$ cat test.c
[sx@VM-4-9-centos dir]$ vim test.c
[sx@VM-4-9-centos dir]$ ls
ls: cannot open directory .: Permission denied
```

这里貌似没问题，但是通常来说要想来说访问目录下的文件，就应该先能查看目录有哪些文件，目录无r权限，但这里通过我们的记忆记住了目录下文件名而去访问了该目录下的文件，这其实是有问题的，但系统可能允许我们这样做，明确的说这是bug。出现这种情况的原因可能是文件名和文件编号是有映射关系的，有可能被系统缓存了。

这也能看出目录内容并不是简单的保存着文件名，文件名和文件编号有映射关系。

