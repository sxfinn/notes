# 2022-04-02-

### 摘要
> 结构体
>
> 结构体类型的声明
>
> 结构的自引用
>
> 结构体变量的定义和初始化
>
> 结构体内存对齐
>
> 结构体传参
>
> 结构体实现位段（位段的填充&可移植性）
>
> 枚举
>
> 枚举类型的定义
>
> 枚举的优点
>
> 枚举的使用
>
> 联合
>
> 联合类型的定义
>
> 联合的特点
>
> 联合大小的计算

### 总结
> 

目录
---
[TOC]

------

### 结构体的声明

常规的结构的声明太过简单常见，不再过多阐述。

#### 特殊声明

在声明结构体的时候可以不完全的声明

```c
struct
{
	int i;
	double d;
	char c;
}x;

struct
{
	int i;
	double d;
	char c;
}arr[10], * px, x1;

```

注意到上面两个结构体的声明并没有标签

也就是说我们只能在声明结构体的时候创建变量，一旦声明结束，就再也找不到这个结构体的标签，自然无法使用它创建变量。

那么还要一个问题：

上面的 x1和x一样吗？

或者说下面这个代码非法吗？

```c
px = &x;
```

**警告：**
编译器会把上面的两个声明当成完全不同的两个类型。
所以是非法的。



#### 结构的自引用

在结构体中包含一个类型为该结构本身的成员可行吗？

```c
//代码1
struct Node
{
	int data;
	struct Node next;
};
//可行否？
如果可以，那sizeof(struct Node)是多少？
```

显然这是不行的，它会无休止的递归下去，非法。

正确打开方式：

```c
//代码2
struct Node
{
	int data;
	struct Node* next;
};
```

而结构体中包含一个自身结构体的指针就不存在这个问题了，结构体的大小是确定的，并且可以在结构体中访问和自身类型一样的结构体。

每次定义变量都要加个struct实在麻烦，我们使用typedef将代码简化一下，下面对吗？

```c
//代码3
typedef struct
{
	int data;
	Node* next;
}Node;
//这样写代码，可行否？
//答案是不行的，在结构体内typedef还没有将这个类型重新定义一个名字，自然无法使用这个新类型。
//解决方案：
typedef struct Node
{
	int data;
	struct Node* next;
}Node;
```



#### 结构体变量的定义和初始化

有结构体的声明，那么定义一个结构体再简单不过了，就和定义普通变量一样就好。

```c
struct Point
{
	int x;
	int y;
}p1; //声明类型的同时定义变量p1,p1是全局的

struct Point p2; //定义结构体变量p2，全局的

//初始化：定义变量的同时赋初值。
struct Point p3 = { x ,y };//类似数组初始化

struct Stu     //类型声明
{
	char name[15];//名字
	int age;    //年龄
};

struct Stu s = { "zhangsan", 20 };//初始化
struct Node
{
	int data;
	struct Point p;
	struct Node* next;
}n1 = { 10, {4,5}, NULL }; //结构体嵌套初始化
struct Node n2 = { 20, {5, 6}, NULL };//结构体嵌套初始化
```



#### 结构体内存对齐

我们已经掌握了结构体的基本使用了。

现在我们深入讨论一个问题：计算结构体的大小。这也是一个特别热门的考点： `结构体内存对齐`

试试计算下面结构体的大小

```c
//练习1
struct S1
{
	char c1;
	int i;
	char c2;
};
printf("%d\n", sizeof(struct S1));
//练习2
struct S2
{
	char c1;
	char c2;
	int i;
};
printf("%d\n", sizeof(struct S2));
//练习3
struct S3
{
	double d;
	char c;
	int i;
};
printf("%d\n", sizeof(struct S3));
//练习4-结构体嵌套问题
struct S4
{
	char c1;
	struct S3 s3;
	double d;
};
printf("%d\n", sizeof(struct S4));
```

难道对齐数只是成员变量大小的简单相加吗？

显然不是，要考虑一些其他问题设计结构体。

**考点**

如何计算？

首先得掌握结构体的对齐规则：

> 1. 第一个成员在与结构体变量偏移量为0的地址处。
>
> 2. 其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。
>
> ​       对齐数 = 编译器默认的一个对齐数 与 该成员大小的较小值。
>
> ​       VS中默认的值为8
>
> 3. 结构体总大小为最大对齐数（每个成员变量都有一个对齐数）的整数倍。
>
> 4. 如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍。



**为什么会存在内存对齐**

> 参考

1. **平台原因(移植原因)：**

  不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。

2. **性能原因：**

  数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。

简单说：

> 结构体的内存对齐是拿空间来换取时间的做法。

那我们如何设计一个个结构体，既满足我们的使用又可以更节省空间

> 让小的成员尽量集中在一起

```c
//例如：
struct S1
{
	char c1;
	int i;
	char c2;
};
struct S2
{
	char c1;
	char c2;
	int i;
};
```

来计算一下它们的大小。

S1 = 4 + 4 + 4 = 12

S2 = 1 + 1 + 2 + 4 = 8

虽然成员一模一样但因为位置不同，大小也不同。



#### 修改默认对齐数

之前我们见过了 `#pragma` 这个预处理指令，这里我们再次使用，可以改变我们的默认对齐数。

通常是`#pragma once`，用来防止头文件的重复包含。

```c
#include <stdio.h>
#pragma pack(8)//设置默认对齐数为8
struct S1
{
	char c1;
	int i;
	char c2;
};
#pragma pack()//取消设置的默认对齐数，还原为默认
#pragma pack(1)//设置默认对齐数为1
struct S2
{
	char c1;
	int i;
	char c2;
};
#pragma pack()//取消设置的默认对齐数，还原为默认
int main()
{
	//输出的结果是什么？
	printf("%d\n", sizeof(struct S1));
	printf("%d\n", sizeof(struct S2));
	return 0;
}
```

>  在对齐方式不太合理时，我们可以修改默认默认对齐数。

> 写一个宏，计算结构体中某变量相对于首地址的偏移，并给出说明。

 offsetof 宏的实现

```c
#define offsetof(S,m) &(((S*)0)->m)
```

S为类型，m为成员变量名。

将0强制转换为一个S结构体的地址，那么我们只要取得成员变量的地址就是偏移量了。



#### 结构体传参

代码：

```c
struct S
{
	int data[1000];
	int num;
};
struct S s = { {1,2,3,4}, 1000 };
//结构体传参
void print1(struct S s)
{
	printf("%d\n", s.num);
}
//结构体地址传参
void print2(struct S* ps)
{
	printf("%d\n", ps->num);
}
int main()
{
	print1(s);  //传结构体
	print2(&s); //传地址
	return 0;
}
```

> 函数传参的时候，参数是需要压栈，会有时间和空间上的系统开销。
>
> 如果传递一个结构体对象的时候，结构体过大，参数压栈的的系统开销比较大，所以会导致性能的下降。

**结论：尽量选择结构体传地址。**



### 位段

#### 什么是位段

位段的声明和结构是类似的，有两个不同：

> 1. 位段的成员必须是 int、unsigned int 或signed int 。
> 2. 位段的成员名后边有一个冒号和一个数字。
> 3. 位段山给的空间是安装需要4个字节或一个字节的方式开辟的。
> 4. 位段不跨平台，注重可移植的程序慎用。

比如：

```c
struct A
{
	int _a : 2;//占2个bit
	int _b : 5;//占5个bit
	int _c : 10;//占10个bit
	int _d : 30;//占30个bit，_d会全部放入新空间与否，这是不确定的。
};
printf("%d", sizeof(struct A));
```

并且这里的 _a,  _b  ,  _c  , _d 不能超过其类型的大小，这里是int所以都不能超过32个bit。

A就是一个位段类型。

那么位段A的大小是多少？

输出：

> 8

这个大小很奇怪，所以先了解一下位段的内存分配方式。

#### 成员空间的开辟方式

1. 位段中全为int， 所以开辟1个（int），即4个byte。
2. 将成员依次放入。
3. 若空间不够，再次开辟4byte

至于不够的空间是会继续使用，还是弃用，这都是不确定的，即标准未定义，在VS下，不够用的空间会直接舍弃，而将数据全放入新空间。



#### 在VS中

1. 将每个成员的数据放入开辟好的内存中是先放到低bit位的
2. 当上一个开辟的空间不够下一个成员使用，则上一个空间会被浪费。
3. 每次开辟新空间，从低地址向高地址开辟。
4. 若数据的bit位数多余我们给他的bit位数，那么会截断。

#### 位段的内存分配

1. 位段的成员可以是 int unsigned int signed int 或者是 char （属于整形家族）类型
2. 位段的空间上是按照需要以4个字节（ int ）或者1个字节（ char ）的方式来开辟的。
3. 位段涉及很多不确定因素，位段是不跨平台的，注重可移植的程序应该避免使用位段。

```c
struct S
{
	char a : 3;
	char b : 4;
	char c : 5;
	char d : 4;
};

int main()
{
	struct S s = { 0 };
	s.a = 10;
	s.b = 12;
	s.c = 3;
	s.d = 4;
	//空间是如何开辟的？
	return 0;
}
```

如图：

![image-20220518224551451](https://pic.xinsong.xyz/img/202205182245502.png)





![image-20220518224557842](https://pic.xinsong.xyz/img/202205182245911.png)



#### 位段跨平台问题

> 1. int 位段被当成有符号数还是无符号数是不确定的。
> 2. 位段中最大位的数目不能确定。（16位机器最大16，32位机器最大32，写成27，在16位机器会出问题。
> 3. 位段中的成员在内存中从左向右分配，还是从右向左分配标准尚未定义。
> 4. 当一个结构包含两个位段，第二个位段成员比较大，无法容纳于第一个位段剩余的位时，是舍弃剩余的位还是利用，这是不确定的。



#### 位段的应用

![image-20220518224603844](https://pic.xinsong.xyz/img/202205182246905.png)



<strong style="color:#7030a0;">总结：与结构相比，位段可以达到同样的效果，可以很好的节省空间。
</strong>

<strong style="color:#7030a0;">
</strong><strong style="color:#7030a0;">位段中如果都为int， 则每次开辟一个int大小的空间， 在内存中一个int的数据也是存在大小端的存储方式，并且按照声明顺序，先使用低位，再使用高位， 若数据溢出，则截断。
</strong>

<strong style="color:#7030a0;">
</strong>

### 枚举

枚举顾名思义就是一一列举咯

在概率论中也常常会用到这种枚举思想。

比如我们现实生活中：一周的周一到周日我们可以一一列举出来，则有穷就可以枚举。

#### 枚举类型的定义

```c
enum Day//星期
{
	Mon,
	Tues,
	Wed,
	Thur,
	Fri,
	Sat,
	Sun
};
enum Sex//性别
{
	MALE,
	FEMALE,
	SECRET
};
enum Color//颜色
{
	RED,
	GREEN,
	BLUE
};
```

以上定义的enum Day, enum Sex, enum Color都是枚举类型

{}中的是枚举类型的可能取值，也叫做枚举常量。

这些可能取值都是数值，默认从0开始逐个增加1，也可在定义的时候赋值。

```c
enum Color//颜色
{
	RED = 1,
	GREEN = 2,
	BLUE = 4
};
```

如果我们没有赋值的话，那么默认值是从0 到 2.

#### 枚举的优点

我们可以使用 #define 定义常量，为什么非要使用枚举？

**枚举的优点：**

1. 增加代码的可读性和可维护性；
2. 和#define定义的标识符比较枚举有类型检查，更加严谨；
3. 防止了命名污染（封装）；
4. 便于调试；
5. 使用方便，一次可以定义多个常量；

```c
enum Color//颜色
{
	RED = 1,
	GREEN = 2,
	BLUE = 4
};
enum Color clr = GREEN;//只能拿枚举常量给枚举变量赋值，才不会出现类型的差异。
clr = 5;
```

**总结：枚举类型和`#define` 有相似之处，枚举变量的取值只能在枚举常量中去取，但是由于认为常量是整形，所以其大小也是一个整形，硬要给枚举变量赋值一个int的值，也不会出什么问题， 因此 `int` 的变量也是可以被枚举常量赋值的。**



### 联合(共用体)

#### 联合类型的定义

联合也是一种特殊的自定义类型。

这种类型定义的变量也包含一系列的成员，特征是这些成员公用同一块空间（所以联合也叫共用体）。

比如：

```c
//联合类型的声明
union Un
{
	char c;
	int i;
};
//联合变量的定义
union Un un;
//计算连个变量的大小
printf("%d\n", sizeof(un));
```

联合的大小是成员大小的累加吗？



#### 联合的特点

> 联合的成员是共用同一块内存空间的，这样一个联合变量的大小，至少是最大成员的大小（因为联合至少得有能力保存最大的那个成员）。

```c
union Un
{
	int i;
	char c;
};
union Un un;
// 下面输出的结果是一样的吗？
printf("%d\n", &(un.i));
printf("%d\n", &(un.c));
//下面输出的结果是什么？
un.i = 0x11223344;
un.c = 0x55;
printf("%x\n", un.i);
```

输出：

![image-20220518224613259](https://pic.xinsong.xyz/img/202205182246298.png)

i 和 c的地址是一样的，那就意味成它们的首地址是一样的。

再来看看修改c后，i的值也变了，那这就足以说明在联合中成员是共用一块内存的。

注意这里修改c的值影响i还受到大小端字节序的问题。



#### 判断当前机器大小端

```c
int main()
{
	int a = 1;
	char* pc = (char*)&a;
	if (*pc == 1)
		printf("小端\n");
	else
		printf("大端\n");
	return 0;
}
```

取出 a 的首地址，首地址是第一个字节，即低地址，用char* 的指针接收，访问当前字节的内容，如果数值为 1 ，就说明 首地址 存储的是低位，即低位存储在低地址处，即小端，反之大端。



#### 联合大小的计算

* 联合的大小至少是最大成员的大小。
* 当最大成员大小不是最大对齐数的整数倍的时候，就要对齐到最大对齐数的整数倍。

比如：

```c
union Un1
{
	char c[5];
	int i;
};
union Un2
{
	short c[7];
	int i;
};
//下面输出的结果是什么？
printf("%d\n", sizeof(union Un1));
printf("%d\n", sizeof(union Un2));
```

**注意：当联合中存在数组时，那么该成员的对齐数，是其元素的大小和默认对齐数的较小值，结构中也是如此。**

