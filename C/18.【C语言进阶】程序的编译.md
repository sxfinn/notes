# 2022-04-03-

### 摘要
> 程序的翻译环境
>
> 程序的执行环境
>
> 详解：C语言程序的编译+链接
>
> 预定义符号介绍
>
> 预处理指令 #define
>
> 宏和函数的对比
>
> 预处理操作符#和##的介绍
>
> 命令定义
>
> 预处理指令 #include
>
> 预处理指令 #undef
>
> 条件编译

### 总结
> 

目录
---
[TOC]

------

### 程序的翻译环境和执行环境
在ANSIC的任何一种实现中，存在两个不同的环境。

> 第1种是翻译环境，在这个环境中源代码被转换为可执行的机器指令。
>
> 第2种是执行环境，它用于实际执行代码。



### 详解编译+链接

#### 翻译环境

![image-20220518223859150](https://pic.xinsong.xyz/img/202205182238236.png)

* 组成一个程序的每个源文件通过编译过程分别转换成目标代码（object code）。
* 每个目标文件由链接器（linker）捆绑在一起，形成一个单一而完整的可执行程序。
* 链接器同时也会引入标准C函数库中任何被该程序所用到的函数，而且它可以搜索程序员个人的程序库，将其需要的函数也链接到程序中。

​	

#### 编译的过程

```c
sum.c
int g_val = 2016;
void print(const char *str)
{
	printf("%s\n", str);
}
```

```c
test.c
#include <stdio.h>
int main()
{
	extern void print(char *str);
	extern int g_val;
	printf("%d\n", g_val);
	print("hello bit.\n");
	return 0;
}
```



![image-20220518223907079](https://pic.xinsong.xyz/img/202205182239191.png)

函数只有声明的时候，在test.c中是没有给 _ sum函数分配地址的，在_sum函数中定义的sum.c中才记录有 _ sum 函数的地址，在链接时，会有**符号表的合并**和符号表的重定位，这也是为什么即使我们没有声明函数直接调用定义在另一个源文件中的函数，也仍能够跑起来，并且只是弹出警告的原因。

**接下来我们在linux下一步一步看发生了什么**

**预处理**

![image-20220518223914530](https://pic.xinsong.xyz/img/202205182239575.png)

运行如上简单程序。

![image-20220518223920420](https://pic.xinsong.xyz/img/202205182239458.png)



可以看到当前目录下只有`test.c`文件

![image-20220518223926268](https://pic.xinsong.xyz/img/202205182239308.png)

使用`gcc -E test.c -o test.i`预处理命令

并将产生的的结果放在`test.i`中，可以看到我们本目录下多了一个`test.i`文件，我们来看看其中的内容。

![image-20220518223935360](https://pic.xinsong.xyz/img/202205182239518.png)

![image-20220518223943043](https://pic.xinsong.xyz/img/202205182239182.png)

文件内容略长，我们仅仅看开头和结尾，开头是头文件的包含内容，包括链接库的路径等等。

结尾就是我们所写的函数了可以看到被处理的仅仅是预处理指定 `#include` 。

**编译**

![image-20220518223951614](https://pic.xinsong.xyz/img/202205182239665.png)



使用`gcc -S test.i -o test.s` 编译命令

并且将结果输出到`test.s`文件

接下来看看这个文件是什么？

![image-20220518224001601](https://pic.xinsong.xyz/img/202205182240744.png)

嗯~这里已经没有那么多的文件内容了，不懂没关系，大致能看出来这是汇编指令了。

那么说明这里是将程序编译为汇编语言。



**汇编**

![image-20220518224013427](https://pic.xinsong.xyz/img/202205182240470.png)

同样的执行`gcc -c test.s -o test.o`汇编指令

汇编完成之后就停下来，结果保存在`test.o`中，看到test.o已经存在了。

继续进入`test.o`中查看：

![image-20220518224021058](https://pic.xinsong.xyz/img/202205182240225.png)

这下谁也看不懂了，因为汇编会将汇编语言编程机器二进制语言，而我们使用的是文本编辑器，所以都是乱码。

那么这个`test.o`可以直接运行吗，试一下：

![image-20220518224028057](https://pic.xinsong.xyz/img/202205182240094.png)

没有权限，并且这被当作是一个普通文件，并不是可执行文件。

![image-20220518224035232](https://pic.xinsong.xyz/img/202205182240275.png)



使用`gcc -o test test.o`命令，继续看看，我们通过`test.o`生成了一个test可执行文件。

执行结果：

![image-20220518224045653](https://pic.xinsong.xyz/img/202205182240710.png)



我们的`hello linux!`就输出到我们的屏幕上了。



#### 运行环境

程序执行的过程：
1. 程序必须**载入内存**中。在有操作系统的环境中：一般这个由操作系统完成。在独立的环境中，程序的载入必须由手工安排，也可能是通过可执行代码置入只读内存来完成。
2. 程序的执行便开始。接着便调用**main函数**。
3. 开始执行程序代码。这个时候程序将使用一个运行时**堆栈（stack）**，存储函数的局部变量和返回地址。程序同时也可以使用静态（static）内存，存储于静态内存中的变量在程序的整个执行过程一直保留他们的值。
4. **终止程序**。正常终止main函数；也有可能是意外终止。

程序载入内存中可以简单想象为将变量数据将函数指令等，载入内存中某些特定的位置，并记录这个地址，让我们运行程序时可以根据需要访问这些地址上存储的指令或者数据。



### 预处理详解

#### 预处理符号

```c
__FILE__    //进行编译的源文件
__LINE__   //文件当前的行号
__DATE__   //文件被编译的日期
__TIME__   //文件被编译的时间
__STDC__   //如果编译器遵循ANSI C，其值为1，否则未定义
```

这些预定义符号都是语言内置的。

例子：

```c
printf("file:%s line:%d\n", __FILE__, __LINE__);
```

![image-20220518224054329](https://pic.xinsong.xyz/img/202205182240370.png)

所在的文件，以及文件当前的行号就被打印出来了。

#### #define

##### #define定义标识符

例子：

```c
#define MAX 1000 //预处理过程中会将MAX替换成1000
#define reg register      //为 register这个关键字，创建一个简短的名字
#define do_forever for(;;)   //用更形象的符号来替换一种实现
#define CASE break;case     //在写case语句的时候自动把 break写上。
// 如果定义的 stuff过长，可以分成几行写，除了最后一行外，每行的后面都加一个反斜杠(续行符)。
#define DEBUG_PRINT printf("file:%s\tline:%d\t \
             date:%s\ttime:%s\n" ,\
             __FILE__,__LINE__ ,    \
             __DATE__,__TIME__ ) 
```

问题来了，通常一个语句末尾会加上 `;`，那么这里需要加上吗？

比如：

```c
#define MAX 1000;
#define MAX 1000
```

>  建议不要加上 ; ,这样容易导致问题。

例如：

```c
if(condition)
	max = MAX;
else
	max = 0;
```

我们知道MAX在预处理后会被替换为 `1000；`，那么就变成了下面：

```c
if(condition)
	max = 1000;
	;
else
	max = 0;
```

由于else和if并不是紧挨着，而是有一条空语句，那么else就无法生效，就有语法错误。



##### **#define 定义宏**

> #define 机制包括了一个规定，允许把参数替换到文本中，这种实现通常称为宏（macro）或定义宏（define macro）。

下面是宏的申明方式：
`#define name( parament-list ) stuff`，其中的 `parament-list` 是一个由逗号隔开的符号表，它们可能出现在stuff中。

注意：
参数列表的左括号必须与name紧邻。

如果两者之间有任何空白存在,参数列表就会被认为是要替换的部分，参数列表就会被解释为stuff的一部分。



如下：

```c
#define SQUARE( x ) x * x
```

这个宏接收一个参数 x .

如果在上述声明之后，你把

```c
SQUARE( 2 );
```

置于程序中，那么这个表达式会被替换为 5 * 5.

替换嘛，总是存在一些问题，通常会因为优先级的问题，导致实际结果和我们预估的不太一样。

例如：

```c
#define SQUARE(X) X * X

int main()
{
	int i = 2
	printf("%d", SQUARE(i + 1));
	return 0;
}
```

不注意看可能就认为会输出 9 了，事实上它会在屏幕上输出 5 。

为什么?

> 替换文本时，参数x被替换成a + 1,所以这条语句实际上变成了：printf ("%d\n",a + 1 * a + 1 );

可以看到，该表达式执行的运算的优先级与我们想的并不同，解决这个问题，在宏定义上加上两个括号就行。

```c
#define SQUARE(X) (X) * (X)
```

这样在预处理替换后，代码就如下：

```c
#define SQUARE(X) (X) * (X)

int main()
{
	int i = 2
	printf("%d", (i + 1) * (i + 1));
	return 0;
}
```

当前问题算是解决了。

这里还有一个宏定义：

```c
#define DOUBLE(x) (x) + (x)
```

定义中我们使用了括号，想避免之前的问题，但是这个宏可能会出现新的错误。

如下：

```c
int a = 5;
printf("%d\n" ,10 * DOUBLE(a));
```

我们本想用DOUBLE(a),来完成乘 2 的操作，结果再和 10 相乘，这样看来答案是 100 .

事实上这里将会打印出 55。

仍然查看替换后的代码：

```c
int a = 5;
printf("%d\n" ,10 * (a) + (a));
```

乘法的优先级高于加法，所以出现了不可预料的答案。

这个问题的解决办法是在宏定义表达式两边加上一对括号就可以了。

```c
#define DOUBLE( x)  ( ( x ) + ( x ) )
```

> 所以用于对数值表达式进行求值的宏定义都应该用这种方式加上括号，避免在使用宏时由于参数中的操作符或邻近操作符之间不可预料的相互作用



##### **#define替换规则**

在程序中扩展#define定义符号和宏时，需要涉及几个步骤。
1. 在调用宏时，首先对参数进行检查，看看是否包含任何由#define定义的符号。如果是，它们首先被替换。
2. 替换文本随后被插入到程序中原来文本的位置。对于宏，参数名被他们的值所替换。
3. 最后，再次对结果文件进行扫描，看看它是否包含任何由#define定义的符号。如果是，就重复上述处理过程。

**注意：**

1. 宏参数和#define 定义中可以出现其他#define定义的符号。但是对于宏，不能出现递归。
2. 当预处理器搜索#define定义的符号的时候，字符串常量的内容并不被搜索。



##### **\## 和 #**

如何把参数插入到字符串中？

首先我们看看这样的代码：

```c
char* p = "hello ""sx\n";
printf("hello"," sx\n");
printf(p);//直接将地址作为参数，这和下面的方式是一样的,都是去访问地址上的数据
printf("%s", p);
```

这里输出的是不是
`hello sx`？

答案是确定的：是。
我们发现字符串输出是有自动连接的特点的。

1. 那我们是不是可以写这样的代码？：

```c
#define PRINT(FORMAT, VALUE)\
	printf("the value is "FORMAT"\n", VALUE);
PRINT("%d", 10);
```

这里只有当字符串作为宏参数的时候才可以把字符串放在字符串中。

1. 另外一个技巧是：使用 # ，**把一个宏参数变成对应的字符串。**

例如：

```c
int i = 10;
#define PRINT(FORMAT, VALUE)\
printf("the value of " #VALUE "is "FORMAT "\n", VALUE);
...
PRINT("%d", i+3);//产生了什么效果
```

代码中的 #VALUE 会预处理器处理为：`"VALUE"` .

最终的输出的结果应该是：

```c
the value of i+3 is 13
```



##### **\##的作用**

> ##可以把位于它两边的符号合成一个符号。
>
> 它允许宏定义从分离的文本片段创建标识符。

```c
#define ADD_TO_SUM(num, value) \
sum##num += value;
...
ADD_TO_SUM(5, 10);//作用是：给sum5增加10.
```

实际上执行的是：

sum和num合并为一个标识符：sum5

sum5 += 10;

**注意**：

**这样的连接必须产生一个合法的标识符。否则其结果就是未定义的。**



##### **带副作用的宏参数**

当宏参数在宏的定义中出现超过一次的时候，如果参数带有副作用，那么你在使用这个宏的时候就可能出现危险，导致不可预测的后果。副作用就是表达式求值的时候出现的永久性效果。
例如：

```c
x+1;//不带副作用
x++;//带有副作用
```

MAX宏可以证明具有副作用的参数所引起的问题。

```c
#define MAX(a, b) ( (a) > (b) ? (a) : (b) )
x = 5;
y = 8;
z = MAX(x++, y++);
printf("x=%d y=%d z=%d\n", x, y, z);//输出的结果是什么？
```

我们将代码中的宏进行替换：

```c
z = ( (x++) > (y++) ? (x++) : (y++));
```

输出：

```c
x=6 y=10 z=9
```

要避免写出这样的代码，宏是无法调试的，一旦没搞清楚，比较麻烦。



##### **宏和函数对比**

宏通常被应用于执行简单的运算。

比如在两个数中找出较大的一个。

```c
#define MAX(a, b) ((a)>(b)?(a):(b))
```

那为什么不用函数来完成这个任务？

原因有二：

1. 用于调用函数和从函数返回的代码可能比实际执行这个小型计算工作所需要的时间更多。**所以宏比函数在程序的规模和速度方面更胜一筹。**
2. 更为重要的是函数的参数必须声明为特定的类型。所以函数只能在类型合适的表达式上使用。反之这个宏怎可以适用于整形、长整型、浮点型等可以用于来比较的类型。**宏是类型无关的。**

**宏的缺点**：当然和函数相比宏也有劣势的地方：

1. 每次使用宏的时候，一份宏定义的**代码将插入到程序中**。除非宏比较短，否则可能大幅度增加程序的长度。
2. 宏是没法**调试**的。

3. 宏由于**类型无关**，也就不够严谨。
4. 宏可能会带来**运算符优先级**的问题，导致程容易出现错。

如果一个程序中多次重复地使用一个功能，那么还是尽量避免使用宏来实现，这样子会造成**代码膨胀**，尤其是代码量比较多地宏，更应避免使用，宏地最佳使用场景就是一些简单功能地实现。

如果宏比较复杂，且多次在程序中替换，**那么就会有大量地重复代码**，而函数永远是解决代码复用的最佳工具，宏被替换到栈帧中，就算这个宏的功能已经完成，但是由于当前栈帧仍需使用，宏的指令变会一直存在与栈帧空间中，直到栈帧被释放。

而函数在调用时会进行压栈，**开辟新的栈帧空间**，当它的使命完成后，就会返回上一层栈帧并自动销毁，这样的方式很好的解决了宏的缺陷，即——指令结束使命后 “ 占着茅坑不拉屎 “ 的问题。

宏有时候可以做函数做不到的事情。比如：宏的参数可以出现类型，但是函数做不到。

```c
#define MALLOC(num, type)\
(type *)malloc(num * sizeof(type))
...
//使用
MALLOC(10, int);//类型作为参数
//预处理器替换之后：
(int *)malloc(10 * sizeof(int));
```

这确实是一个很厉害的一点，由于宏替换的性质，宏的参数可以是任何标识符，数字，或者是其他东西，有点来者不拒的感觉，但这同时也是它的缺点，没有类型检查，好比人人都有你家钥匙，指不定哪天就出问题了。



##### **宏和函数的一个对比**

| 属性             | #define定义宏                                                | 函数                                                         |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 代码长度         | 每次使用时，宏代码都会被插入到程序中。除了非常小的宏之外，程序的长度会大幅度增长 | 函数代码只出现于一个地方；每次使用这个函数时，都调用那个地方的同一份代码 |
| 执行速度         | 更快                                                         | 存在函数的调用和返回的额外开销，所以相对慢一些               |
| 操作符优先级     | 宏参数的求值是在所有周围表达式的上下文环境里，除非加上括号，否则邻近操作符的优先级可能会产生不可预料的后果，所以建议宏在书写的时候多些括号。 | 函数参数只在函数调用的时候求值一次，它的结果值传递给函数。表达式的求值结果更容易预测。 |
| 带有副作用的参数 | 参数可能被替换到宏体中的多个位置，所以带有副作用的参数求值可能会产生不可预料的结果。 | 函数参数只在传参的时候求值一次，结果更容易控制。             |
| 参数类型         | 宏的参数与类型无关，只要对参数的操作是合法的，它就可以使用于任何参数类型。 | 函数的参数是与类型有关的，如果参数的类型不同，就需要不同的函数，即使他们执行的任务是不同的。 |
| 调试             | 宏是不方便调试的                                             | 函数是可以逐语句调试的                                       |
| 递归             | 宏是不能递归的                                               | 函数是可以递归的                                             |

宏无法递归，因为在定义宏的时候写出自身宏的时候，是无法识别的，宏只有被完整的定义之后，才被编译器当作可识别的宏。

例如：

```c
#define SUM(n) (n > 0 ? (n + SUM(n - 1)) : 0)
```

这个宏还没定义完呢，就又想使用这个宏，显然不太合理。



##### **命名约定**

一般来讲函数的宏的使用语法很相似。所以语言本身没法帮我们区分二者。
那我们平时的一个习惯是：

> 把宏名全部大写
>
> 函数名不要全部大写



**undef**

这条指令用于移除一个宏定义。

```c
#undef NAME
//如果现存的一个名字需要被重新定义，那么它的旧名字首先要被移除。
```

例如：

```c
#define MAX 10
#undef MAX
int a = MAX;
```

这里的程序就出现了错误，在编译器看来，MAX是个未定义的标识符。



##### **命令行定义**

许多C 的编译器提供了一种能力，允许在命令行中定义符号。用于启动编译过程。

例如：当我们根据同一个源文件要编译出不同的一个程序的不同版本的时候，这个特性有点用处。（假定某个程序中声明了一个某个长度的数组，如果机器内存有限，我们需要一个很小的数组，但是另外一个机器内存大些，我们需要一个数组能够大些。）

```c
#include <stdio.h>
int main()
{
  	int array [ARRAY_SIZE];
  	int i = 0;
  	for(i = 0; i< ARRAY_SIZE; i ++)
 	{
    	array[i] = i;
 	}
  for(i = 0; i< ARRAY_SIZE; i ++)
 	{
    	printf("%d " ,array[i]);
 	}
  	printf("\n" );
  	return 0;
}
```

编译指令：

```c
//linux 环境演示
gcc -D ARRAY_SIZE=10 programe.c
```



##### **条件编译**

在编译一个程序的时候我们如果要将一条语句（一组语句）编译或者放弃是很方便的。因为我们有条件编译指令。

比如说：

> 调试性的代码，食之无味，弃之可惜，所以我们可以选择性的编译。

```c
#include <stdio.h>
#define __DEBUG__
int main()
{
	int i = 0;
	int arr[10] = {0};
	for(i=0; i<10; i++)
	{
		arr[i] = i;#ifdef __DEBUG__
		printf("%d\n", arr[i]);//为了观察数组是否赋值成功。
		#endif //__DEBUG__
	}
	return 0;
}
```

常见的条件编译指令：

```c
1.
#if 常量表达式
	//...
#endif
//常量表达式由预处理器求值。
如：
#define __DEBUG__ 1
#if __DEBUG__
	//..
#endif
2.多个分支的条件编译
#if 常量表达式
	//...
#elif 常量表达式
	//...
#else
	//...
#endif
3.判断是否被定义
#if defined(symbol)
#ifdef symbol
    
#if !defined(symbol)
#ifndef symbol
    
4.嵌套指令
#if defined(OS_UNIX)
	#ifdef OPTION1
		unix_version_option1();
	#endif
	#ifdef OPTION2
		unix_version_option2();
	#endif
#elif defined(OS_MSDOS)
	#ifdef OPTION2
		msdos_version_option2();
	#endif
#endif
```



##### **文件包含**

我们已经知道， `#include` 指令可以使另外一个文件被编译。就像它实际出现于 #include 指令的地方一样。

这种替换的方式很简单，预处理器先删除这条指令，并用包含文件的内容替换。这样一个源文件被包含10次，那就实际被编译10次。

**头文件被包含的方式**

* 本地头文件包含

```c
#include "filename"
```

查找策略：先在源文件所在根目录下查找，如果该头文件未找到，编译器就像查找库函数头文件一样在标准位置查找头文件。

如果找不到就提示编译错误。

**Linux环境的标准头文件的路径：**

![image-20220518224108875](https://pic.xinsong.xyz/img/202205182241990.png)

**VS环境的标准头文件的路径：**

```c
C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\include
```

**库文件包含**

```c
#include<filename.h>
```

查找头文件直接去标准路径下去查找，如果找不到就提示编译错误。这样是不是可以说，对于库文件也可以使用 “ ” 的形式包含？

**答案是肯定的，可以。**

但是这样做查找的效率就低些，当然这样也不容易区分是库文件还是本地文件了。

**嵌套文件包含**

如果出现这样的场景：

![image-20220518224115729](https://pic.xinsong.xyz/img/202205182241813.png)

`conmm.h`和`conmm.c`是公共模块。
`add.h`和`add.c`使用了公共模块。
`multi.h`和`multi.c`使用了公共模块。
`test.h`和`test.c`使用了add模块和multi模块。
这样最终程序中就会出现两份`comm.h`的内容。这样就造成了文件内容的重复。

如何解决这个问题？

**答案：条件编译。**

每个头文件的开头写：

```c
#ifndef __TEST_H__
#define __TEST_H__
//头文件的内容
#endif  //__TEST_H__
```

或者

```c
#pragma once
```

就可以避免头文件的重复包含

```c
1. 头文件中的 ifndef/define/endif是干什么用的?
2. #include <filename.h> 和 #include "filename.h"有什么区别?
```

1. 避免头文件重复引入
2. 一个是从标准路径下查找，若找不到则编译错误，第二个是先在当前路径下查找，若找不到，再到标准路径下查找，还是找不到则编译错误。



#### 其他预处理指令

```c
#error
#pragma
#line
#pragma pack()
```

