# 2022-04-03-

### 摘要
> 为什么存在动态内存分配
>
> 动态内存函数的介绍
>
> `malloc`
>
> `free`
>
> `calloc`
>
> `realloc`
>
> 常见的动态内存错误
>
> 柔性数组

### 总结

> 

目录
---
[TOC]

------

### 为什么存在动态内存分配

栈区上的内存开辟

```c
int val = 20;//在栈空间上开辟四个字节
char arr[10] = {0};//在栈空间上开辟10个字节的连续空间
```

这样直接在函数体中开辟内存的方式有它的特点

1. 开辟内存的大小是固定的。
2. 数组在申请空间是，需要指定数组大小。
3. 出了函数作用域变量就失效了。

但是对于空间的需求，不仅仅是上述的情况。有时候我们需要的空间大小在程序运行的时候才能知道，那数组的编译时开辟空间的方式就不能满足了。这时候就只能试试动态存开辟了。

### 动态内存函数

#### [malloc ](https://www.cplusplus.com/reference/cstdlib/malloc/?kw=malloc)和 [free ](https://www.cplusplus.com/reference/cstdlib/free/?kw=free)

C语言提供了一个动态内存开辟的函数：

```c
void* malloc (size_t size);
```

这个函数向内存申请一块连续可用的空间，并返回指向这块空间的指针。

* 如果开辟成功，则返回一个指向开辟好空间的指针。
* 如果开辟失败，则返回一个NULL指针，因此malloc的返回值一定要做检查。
* 返回值的类型是 void* ，所以malloc函数并不知道开辟空间的类型，具体在使用的时候使用者自己来决定。
* 如果参数 size 为0，malloc的行为是标准是未定义的，取决于编译器。



既然是动态内存开辟，那么有开辟内存就一定有释放内存。

C语言提供了另一个函数free，专门用来做动态内存的释放和回收。

```c
void free (void* ptr);
```

free函数用来释放动态开辟的内存。

* 如果参数 `ptr` 指向的空间不是动态开辟的，那free函数的行为是未定义的。
* 如果参数 `ptr` 是NULL指针，则函数什么事都不做。
* 函数执行后，`ptr`仍指向该地址。

想要使用这两个函数，我们需要包含头文件 `stdlib.h`

```c
#include <stdio.h>
int main()
{
	//代码1
	int num = 0;
	scanf("%d", &num);
	int arr[num] = {0};
	//代码2
	int* ptr = NULL;
	ptr = (int*)malloc(num*sizeof(int));
	if(NULL != ptr)//判断ptr指针是否为空
	{
		int i = 0;
		for(i=0; i<num; i++)
		{
			*(ptr+i) = 0；
		}
	}
	free(ptr);//释放ptr所指向的动态内存
	ptr = NULL;//是否有必要？
	return 0;
}
```

使用方式与数组很相似。

如果`ptr`不置空，会有什么问题吗？

自然你是不会犯错的，但一个工程那么源文件，假如你在已经释放过这边空间了，但又没有及时指控，`ptr`却仍然指向原来的地址，好比你邻居有了你家的门钥匙，这可不合理合法，因此最好释放内存后，将指向该空间的指针都及时置空。



#### [calloc ](https://www.cplusplus.com/reference/cstdlib/calloc/?kw=calloc)

C语言还提供了一个函数 `calloc`，它也是用来动态内存分配的。

```c
void* calloc (size_t num, size_t size);
```

* 函数的功能是为 num 个大小为 size 的元素开辟一块空间，并且把空间的每个字节初始化为0。
* 与函数 malloc 的区别只在于 `calloc` 会在返回地址之前把申请的空间的每个字节初始化为全0。

与malloc相比它显然多了一个功能，不过实在用的很少，完全可以使用`malloc + memset`两个函数代替，不过有还是比没有好的。

来个例子：

```c
#include<stdio.h>
#include<stdlib.h>
int main()
{
	int* ret = (int*)calloc(10, sizeof(int));
	if (ret)
	{
		//
	}
	free(ret);
	ret = NULL;
	return 0;
}
```



![image-20220518224131313](https://pic.xinsong.xyz/img/202205182241396.png)

通过内存窗口看到这里四十个字节的16进制全部都成为了0，那么free又会发生什么？

![image-20220518224138372](https://pic.xinsong.xyz/img/202205182241420.png)

free后这里的数据又都变成了随机值。

如果需要将开辟的内存初始化为0，那么使用`calloc`会很方便。



#### [realloc ](https://www.cplusplus.com/reference/cstdlib/realloc/?kw=realloc)

试想这样一种场景，假如我们申请了40个byte，但是现在却不够用了，那么只依靠`malloc`和`calloc`函数，我们怎么做？难道是另起炉灶，再重新开辟一块空间，这样做显然太笨重了，因此C语言还提供了我们用来动态管理内存空间的函数`realloc`。

* `realloc`函数的出现让动态内存管理更加灵活。
* 有时会我们发现过去申请的空间太小了，有时候我们又会觉得申请的空间过大了，那为了合理的时候内存，我们一定会对内存的大小做灵活的调整。那`realloc` 函数就可以做到对动态开辟内存大小的调整。

函数原型：

```c
void* realloc (void* ptr, size_t size);
```

* `ptr`是要调整的内存的地址
* size是调整后的字节数
* 返回值为调整内存后的首地址
* 这个函数调整原内存空间大小的基础上，还会将原来内存中的数据移动到新的空间。
* `realloc`在调整内存空间的是存在两种情况：
  *  原有空间后有充足的空间
  * 原有空间后没有充足的空间

会出现这两种情况的原因是动态开辟的内存空间是随机的，即可能会形成一块空间上，断断续续的被我们所使用。



![image-20220518224145267](https://pic.xinsong.xyz/img/202205182241355.png)

**情况1**

当是情况1 的时候，原有空间之后没有足够多的空间时，扩展的方法是：在堆空间上另找一个合适大小的连续空间来使用。这样函数返回的是一个新的内存地址。

**情况2**

当是情况2的时候，要扩展内存就直接原有内存之后直接追加空间，原来空间的数据不发生变化。

由于上述的两种情况，`realloc`函数的使用就要注意一些。



这是我们有内存增大需求的情况，如果是减小呢？

* `malloc`在缩小内存时，将后面多余的空间free掉。
* `realloc`找不到合适的空间时会返回NULL。
* 如果`ptr`为NULL，那么它的功能和`malloc`一样。

所以记得对返回的地址进行判空操作。



### 常见的动态内存错误

#### 对空指针的解引用操作

```c
void test()
{
	int *p = (int *)malloc(INT_MAX/4);
	*p = 20;//如果p的值是NULL，就会有问题
	free(p);
}
```

解决方法：对于返回的地址要判空。

#### 对动态开辟空间的越界访问

```c
void test()
{
	int i = 0;
	int *p = (int *)malloc(10*sizeof(int));
	if(NULL == p)
	{
		exit(EXIT_FAILURE);
	}
	for(i=0; i<=10; i++)
	{
		*(p+i) = i;//当i是10的时候越界访问
	}
	free(p);
}
```

#### 对非动态开辟内存使用free释放

```c
void test()
{
	int a = 10;
	int *p = &a;
	free(p);
}
```

p指向栈区而非堆区，free不能释放不是动态内存开辟的空间。

#### 使用free释放一块动态开辟内存的一部分

```c
void test()
{
	int *p = (int *)malloc(100);
	p++;
	free(p);//p不再指向动态内存的起始位置
}
```

会造成内存泄漏。

#### 对同一块内存空间多次释放

```c
void test()
{
	int *p = (int *)malloc(100);
	free(p);
	free(p);//重复释放
}
```

重复释放会导致第二次释放出现问题，释放已经不属于我们的内存空间显然不合适。



#### 动态开辟的空间未释放

```c
void test()
{
	int *p = (int *)malloc(100);
	if(NULL != p)
	{
		*p = 20;
	}
}
int main()
{
	test();
	while(1);
}
```

**忘记释放不再使用的动态开辟的空间会造成内存泄漏**

动态开辟的内存一定要释放，且对于某一组内存操作函数，由谁开辟的，结束后，就由谁释放。

例如：链表的初始化需要动态申请内存空间，那么我们在使用完链表后，在销毁链表的函数中就应释放掉这些内存。

动态开辟的空间一定要释放，并且正确释放 ，多次的内存泄露会导致内存空间被浪费，导致卡顿，直至完全卡死。



### C/C++程序的内存开辟

![image-20220518224158827](https://pic.xinsong.xyz/img/202205182241891.png)

**C/C++程序内存分配的几个区域：**

> 1. 栈区（stack）：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。 栈区主要存放运行函数而分配的局部变量、函数参数、返回数据、返回地址等。
> 2. 堆区（heap）：一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。分配方式类似于链表。
> 3. 数据段（静态区）（static）存放全局变量、静态数据。程序结束后由系统释放。
> 4. 代码段：存放函数体（类成员函数和全局函数）的二进制代码。

有了这幅图，我们就可以更好的理解在《C语言初识》中讲的static关键字修饰局部变量的例子了。

> 实际上普通的局部变量是在栈区分配空间的，栈区的特点是在上面创建的变量出了作用域就销毁。
>
> 但是被static修饰的变量存放在数据段（静态区），数据段的特点是在上面创建的变量，直到程序结束才销毁，所以生命周期变长。
>



### 柔性数组

> 也许你从来没有听说过柔性数组（flexible array）这个概念，但是它确实是存在的。
>
> C99 中，结构中的最后一个元素允许是未知大小的数组，这就叫做『柔性数组』成员。

例如：

```c
typedef struct st_type
{
	int i;
	int a[0];//柔性数组成员
}type_a;
```

有些编译器会报错无法编译可以改成：

```c
typedef struct st_type
{
	int i;
	int a[];//柔性数组成员
}type_a;
```

#### 柔性数组的特点

* 结构中的柔性数组成员前面必须至少一个其他成员。
* sizeof 返回的这种结构大小不包括柔性数组的内存。
* 包含柔性数组成员的结构用malloc ()函数进行内存的动态分配，并且分配的内存应该大于结构的大小，以适应柔性数组的预期大小。

例如：

```c
//code1
typedef struct st_type
{
	int i;
	int a[0];//柔性数组成员
}type_a;
printf("%d\n", sizeof(type_a));//输出的是4
```



#### 柔性数组的使用

```c
//代码1
int i = 0;
type_a *p = (type_a*)malloc(sizeof(type_a)+100*sizeof(int));
//业务处理
p->i = 100;
for(i=0; i<100; i++)
{
	p->a[i] = i;
}
free(p);
```

这样柔性数组成员a，相当于获得了100个整型元素的连续空间。



#### 柔性数组的优势

我们完全可以使用一个在结构体中引入一个指针成员，达到相似的效果。

```c
//代码2
typedef struct st_type
{
	int i;
	int *p_a;
}type_a;
type_a *p = (type_a *)malloc(sizeof(type_a));
p->i = 100;
p->p_a = (int *)malloc(p->i*sizeof(int));
//业务处理
for(i=0; i<100; i++)
{
	p->p_a[i] = i;
}
//释放空间
free(p->p_a);
p->p_a = NULL;
free(p);
p = NULL;
```

这两段代码可以完成相同的功能。

但是使用柔性数组有什么好处呢？

**第一个好处是：方便内存释放**

>如果我们的代码是在一个给别人用的函数中，你在里面做了二次内存分配，并把整个结构体返回给用户。用户调用free可以释放结构体，但是用户并不知道这个结构体内的成员也需要free，所以你不能指望用户来发现这个事。所以，如果我们把结构体的内存以及其成员要的内存一次性分配好了，并返回给用户一个结构体指针，用户做一次free就可以把所有的内存也给释放掉。

**第二个好处是：这样有利于访问速度.**

> 连续的内存有益于提高访问速度，也有益于减少内存碎片。（其实，我个人觉得也没多高了，反正你跑不了要用做偏移量的加法来寻址）



阅读：[C语言结构体里的成员数组和指针 | 酷 壳 - CoolShell](https://coolshell.cn/articles/11377.html)

