# 2022-05-22-

### 摘要
> 再谈构造函数
>
> static成员
>
> C++11的成员初始化
>
> 友元
>
> 内部类
>
> 再次理解封装

### 总结

> 

目录
---
[TOC]

------

## 再谈构造函数

之前讲过构造函数的一些特性，再在这里补充下。

### 构造函数体赋值

---

```cpp
class Date
{
public:
	Date(int year, int month, int day)
	{
		_year = year;
		_month = month;
		_day = day;
	}
private:
	int _year;
	int _month;
	int _day;
};
```

在程序进入函数体时，成员变量的初始化实际上已经完成，具有了初始值，虽然为构造函数的函数体，可实际函数体的赋值操作并不是对成员的初始化，而只能算是对成员的赋值操作。并且初始化操作只能由一次而在函数体内却可对一个变量多次赋值，因此**函数体内的赋值操作不能称为初始化操作**。



### 初始化列表

---

> 初始化列表：以一个**冒号开始**，接着是以**逗号分隔**每个成员列表，每个**成员变量后跟一个括号**，括号内为需要初始化的**初值或者表达式**。

```cpp
class Stack
{
public:
	Stack()
		:
		_size(0),
		_capacity(4),//初值
		_p((int*)malloc(sizeof(int) * _capacity))//表达式
	{}		
private:
	
	int _size;
	int _capacity;
	int* _p;
};
int main()
{
	Stack s;
	return 0;
}
```

至于初始化列表是什么，其实就是类的对象的成员定义的地方。

对象的定义大致三个过程：

1. 为类的对象**分配内存空间**（对象的空间）
2. 在分得的内存空间的基础上**初始化成员变量**（初始化列表、初始化对象）
3. 初始化结束，对成员变量的赋值（函数体）

例如`Date d1(2001,7,28);`

可以先视作为d1分配空间，然后在此空间的基础上走Date构造的初始化列表，初始化列表结束，即初始化结束。

【注意事项】：

1. 每个成员变量在初始化列表中**只能出现一次**(初始化只能初始化一次)
2. 类中包含以下成员，必须放在初始化列表位置显式进行初始化：
  - [x] 引用成员变量
  - [x] const成员变量
  - [x] 自定义成员变量（该类没有默认构造函数）

```cpp
class A
{
public:
	A(int a)
		:
		_a(a)
	{}
private:
	int _a;
};
int global = 0;
class B
{
public:
	B(int b , int aa)
		:
		_b(b),
		_aa(aa),
		_ref(global)
	{}
private:
	const int _b;//const
	int& _ref;//引用
	A _aa;//没有默认构造函数
};
int main()
{
	B tmp(1, 2);
	return 0;
}
```

3. 尽量使用初始化列表初始化，因为不论你是否使用初始化列表，对于自定义类型成员变量，一定会在初始化列表中初始化。通俗来讲就是初始化列表是一定会走一遍的，我们使用初始化列表只是显式的去调用。

```cpp
#include<iostream>
using namespace std;
class Time
{
public:
	Time(int hour = 0)
		:_hour(hour)
	{
		cout << "Time()" << endl;
	}
private:
	int _hour;
};
class Date
{
public:
	Date(int day)
	{}
private:
	int _day;
	Time _t;
};
int main()
{
	Date d(1);
}
```

在Date的构造函数中我们并没有使用初始化列表，但仍然会在初始化列表里调用_t的默认构造函数，而至于为什么初始化列表不去处理内置类型，可以这样理解：

**在普通的定义int类型时通常会这样定义**：

`int a = 10;`或者`int a;`，第一个会将a初始化为10，第二个则是随机值。

**不过也可以用类似于定义自定义类型的方式去定义**：

`int a(10);`显式调用int的构造函数

**注意**：不存在`int a();`这样的定义方式，会被当做函数声明（但在初始化列表里可以写括号但无参，因为初始化列表变量前不带类型，不会被当做函数声明）

**虽然无法像上面这样但有一个匿名变量的写法**：

`int();`，像这样子写会创建一个临时变量，并且值为0，而这和自定义类型的匿名对象方式一样，所以可以看成是**调用了int的默认构造**，而int的默认构造默认初始化成0值。

**所以！！！**大致可认为内置类型的变量有两种初始化方法：

1. 调用了默认构造定义的定义方式；（不给值默认初始化为0）
2. 采用普通的定义方式；（不给值默认随机值）

在类的构造函数的初始化列表中，如果我们没有显式的去初始化内置类型变量，都是默认以普通的方式去定义内置类型，而不是调用内置类型的默认构造函数，而当我们初始化列表中显式的初始化内置类型时，可以看作调用了其构造函数并且可以给初值，而不再使用其默认的普通定义方式。

（注：在初始化列表中初始化内置类型如果括号里不给值，会被初始化为0，也可以看作是调用了默认构造函数，默认构造默认值为0）

如下：

```cpp
class Time
{
public:
	Time(int hour = 0)
		:_hour(hour)
	{
		cout << "Time()" << endl;
	}
private:
	int _hour;
};
class Date
{
public:
	Date(int day)
		:
		_day(),//内置类型和自定义类型都支持这样地无参初始化，调用了默认构造
		_t()//调用默认构造函数
	{}
private:
	int _day;
	Time _t;
};
```

（个人认为如果这里能把内置类型也在初始化列表也处理了就完美了，既方便又好理解）

**总结**：只要调用了构造函数，就会走一遍初始化列表！！！

**对于内置类型**：

​	不显式的去初始化内置类型，走的是默认的普通内置类型定义方式；

​	显式的去初始化内置类型，走的是内置类型的构造函数，即使不给初值也会是零！

**对于自定义类型**：

​	不显式的去初始化自定义类型，走的是调用其默认构造；

​	显式的去初始化自定义类型，走的是调用其默认构造，并且可以给初始化值；

#### 初始化列表的初始化顺序

成员变量在类中的**声明次序**就是其在初始化列表中**初始化的次序**，而与其初始化列表的先后顺序无关。

```cpp
class A
{
public:
	A(int a)
		:_a1(a)
		, _a2(_a1)
	{}
	void Print()
	{
		cout << _a1 << " " << _a2 << endl;
	}
private:
	int _a2;
	int _a1;
};
int main() 
{
	A aa(1);
	aa.Print();
}
```

以上程序会输出什么？

> A.输出1 1
> B.程序崩溃
> C.编译不通过
> D.输出1  随机值

答案是D，根据声明顺序初始化列表一定会先初始化`_a2`，再初始化 `_a1`，而使用`_a1`初始化`_a2`时 `_a1`还是随机值，因此`_a`会被初始化成随机值，而`_a1`会被初始化为`a`的值——1；

### explicit关键字

----

构造函数不仅可以初始化对象，**对于单个参数的构造函数，还具有类型转换的作用**。

```cpp
class Date
{
public:
	Date(int year)
		:_year(year)
	{}
	explicit Date(int year)
		:_year(year)
	{}
private:
	int _year;
	int _month;
	int _day;
};
int main()
{
	Date d1(2018);
	// 用一个整形变量给日期类型对象赋值
	// 实际编译器背后会用2019构造一个无名对象，最后用无名对象给d1对象进行赋值
	d1 = 2019;//有explicit修饰构造函数，2019就无法发生隐式转换，这里会报错；
	Date d2 = 2020;//同理
}
```

> 上述代码可读性不是很好，用**explicit修饰构造函数**，将会**禁止单参构造函数的隐式转换**。

如果没有explicit修饰构造函数的话，这里单参构造函数的隐式转换的过程是先将使用2020构造出一个Date临时对象，再调用拷贝构造去对d1进行拷贝，不过经过编译器的优化，通常会将 **构造+拷贝构造** 优化成 **直接使用2020构造d1.**

## static成员

static修饰全局函数，会改变其链接属性，修饰局部变量，会改变其生命周期。

在类中的static成员有什么作用呢？

#### 概念

> 声明为**static的类成员**称为类的**静态成员**，用**static修饰的成员变量**，称之为**静态成员变量**；用**static修饰的成员函数**，称之为**静态成员函数**。**静态的成员变量一定要在类外进行初始化**。

static有什么特别之处？来看一个题

> 实现一个类，计算中程序中创建出了多少个类对象。

思路：创建类那么一定会调用构造函数，因此从构造函数和拷贝构造调用了多少次入手，考虑定义一个静态的成员变量`_scount`，每调用一次构造函数，都执行一次 `s_count++`操作，再定义一个函数，用于返回静态变量。

```cpp
class A
{
public:
	A() { ++_scount; }
	A(const A& t) { ++_scount; }
	static int GetACount() { return _scount; }
private:
	static int _scount;
};
int A::_scount = 0;
int main()
{
	A a[10];
	cout << A::GetACount() << endl;
	return 0;
}
```

#### 特性

1. **静态成员属于整个类**，因此被所有类对象所共享，而不属于某个对象；
2. **静态成员变量必须在类外定义**，定义时不添加static关键字，需要指定类域；
3. **类静态成员可用类名::静态成员或者对象.成员来访问**；
4. **静态成员函数没有隐含的this指针**，不能访问任何非静态函数；
5. 静态成员和类的普通成员一样，也有public、private、protected三种访问级别；

对于静态成员函数，不需要使用对象去调用，而是只要突破了类域限制，就能访问静态成员，对于以上5个特性我们可以尝试解释：

* **对于静态成员变量**，static修饰会让其生命周期延长（存储于静态区，也叫做数据段），因此需要单独类外定义，类的对象定义时调用构造函数的初始化列表不包括静态成员变量，**静态成员变量不属于某个对象**；

* **对于静态成员函数**，形参列表中没有隐含的this指针，因此不需要对象的地址就能调用，而非静态成员函数由于this指针的存在，即使突破了类域，却仍需要对象的地址才能调用；

【问题】
1. 静态成员函数可以调用非静态成员函数吗？
2. 非静态成员函数可以调用类的静态成员函数吗？

答：**静态成员函数不能调用类的非静态成员函数**，因为静态成员函数形参没有this指针，而调用非静态成员函数需要传值给this指针。

​		**非静态成员函数可以调用类的静态成员函数**，调用静态成员函数，突破类域即可。

我们前面已经学过static修饰全局函数会改变其链接属性，只能在定义的源文件被调用，那这里被static修饰的成员函数会被改变链接属性吗？

我尝试了一下如下代码：

```cpp
//test.h
class Date
{
public:
	Date()
		:
		_year(1),
		_month(1),
		_day(1)
	{}
	static void test();
private:
	int _year;
	int _month;
	int _day;
};

//test.cpp
#include"date.h"
void Date::test()
{
	cout << "test()" << endl;
}

//main.cpp
#include"date.h"
int main()
{
	Date::test();
	return 0;
}
```

可以正常编译运行调用test函数，但如果test是全局函数，则只能在定义test函数的源文件才能调用test函数，因此static修饰全局函数和修饰成员函数是完全不同的。

总结：

* static修饰类的成员函数，不改变链接属性，仅仅影响隐含的this指针；
* static修饰全局函数，改变其链接属性；

## C++11的成员初始化新玩法

---

> C++支持非静态的成员变量在声明时进行初始化赋值，**但是这里不是真正意义上的赋值，这里仅仅只声明，给声明的成员变量缺省值（默认值或者表达式）**。

如下：

```cpp
class Stack
{
public:
	Stack()
        :
    _capacity(8)//这里_capacity会被初始化为8而不是4，我们显式初始化默认值无效。
	{}
private:	
    //非静态成员变量
	int _size = 0;//初始化列表中使用_size(0)初始化
	int _capacity = 4;
	int* _p = (int*)malloc(sizeof(int) * _capacity);//初始化列表中使用_size(malloc)初始化
};
int main()
{
	Stack s;
	return 0;
}
```

实际上这个缺省值是初始化列表的缺省值，对象定义时调用构造函数，初始化列表就会使用这些缺省值去初始化成员变量，**而如果我们自己也写了初始化列表那么缺省值就被覆盖，使用我们给的值去初始化**。

**总结**：类的非静态成员变量声明所给的缺省值，实际上是初始化列表的缺省值，我们不写初始化列表，才会使用这些默认值初始化成员。

值得一提的是只要这个类中有指针类型，那么从一进入构造函数时，在调试窗口看每个成员变量的值都默认为0，直到我们去在初始化列表初始化或者函数体内赋值，用意是什么我也不清楚，可能是为了防止未正确初始化指针变量导致的野指针问题，奇怪奇怪。

## 友元

> 友元分为**友元函数**和**友元类**
>
> 友元提供了一种突破封装的方式，有时提供了便利。但是友元会增加耦合度，破坏了封装，所以友元不宜多用。
> 
>例如一些我们定义的全局函数为了能突破类的封装，可以定义为友元函数。

友元一定是万不得已才使用，毕竟会打破封装。

### 友元函数

问题：现在我们尝试去重载operator<<，然后发现我们没办法将operator<<重载成成员函数。因为cout的输出流对象和隐含的this指针在抢占第一个参数的位置。this指针默认是第一个参数也就是左操作数了。但是实际使用中cout需要作为第一个形参对象，才能正常使用。所以我们要将operator<<重载成全局函数。但是这样的话，又会导致类外没办法访问成员，那么这里就需要友元来解决。operator>>同理。

```cpp
class Date
{
public:
	Date(int year, int month, int day)
		: _year(year)
		, _month(month)
		, _day(day)
	{}
	ostream& operator<<(ostream& _cout)
	{
		_cout << _year << "-" << _month << "-" << _day;
		return _cout;
	}
private:
	int _year;
	int _month;
	int _day;
};

int main()
{
	Date d(2001, 7, 28);
	d << cout;
	return 0;
}
```

**友元函数**是定义在**类外部的全局函数**，不属于任何类，可以直接访问类的私有成员，但需要在类的内部声明，声明需要加上friend关键字。

```cpp
class Date
{
	friend ostream& operator<<(ostream& _cout, const Date& d);
	friend istream& operator>>(istream& _cin, Date& d);
public:
	Date(int year, int month, int day)
		: _year(year)
		, _month(month)
		, _day(day)
	{}
private:
	int _year;
	int _month;
	int _day;
};
ostream& operator<<(ostream& _cout, const Date& d)
{
	_cout << d._year << "-" << d._month << "-" << d._day;
	return _cout;
}
istream& operator>>(istream& _cin, Date& d)
{
	_cin >> d._year;
	_cin >> d._month;
	_cin >> d._day;
	return _cin;
}
int main()
{
	Date d(2001, 7, 28);
	cin >> d;
	cout << d;	
	return 0;
}
```

需要注意的几点：

* 友元函数可访问类的私有和保护成员，但**不是类的成员函数**；
* 友元函数不能用**const修饰**；
* 友元函数可以在类定义的任何地方声明，**不受类访问限定符的限制**；
* 一个函数可以是**多个类的友元**；
* 友元函数的调用与普通函数的调用和原理相同；



### 友元类

友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的非公有成员。

* 友元关系是单向的，不具有交换性。

​		比如下面的这段代码：Date是Time类的友元类，那么可以在Date类的成员函数中直接访问Time类的私有和保护成员，但是想在Time类中访问Date类的私有成员变量则不行。

* 友元关系不能传递。

​		如果B是A的友元，C是B的友元，则无法说C是A的友元。

```cpp
class Date; // 前置声明
class Time
{
	friend class Date; // 声明日期类为时间类的友元类，则在日期类中就直接访问Time类中的私有成员变量
public:
	Time(int hour = 12, int minute = 0, int second = 0)
		: _hour(hour)
		, _minute(minute)
		, _second(second)
	{}
private:
	int _hour;
	int _minute;
	int _second;
};
class Date
{
public:
	Date(int year = 1900, int month = 1, int day = 1)
		:
		_year(year),
		_month(month),
		_day(day)
	{}
	
	void SetTimeOfDate(int hour, int minute, int second)
	{
		// 直接访问时间类私有的成员变量
		_t._hour = hour;
		_t._minute = minute;
		_t._second = second;
	}
private:
	int _year; 
	int _month;
	int _day;
	Time _t;
};

int main()
{
	Date d;
	d.SetTimeOfDate(0, 0, 0);
	return 0;
}
```

## 内部类

### 概念及特性

概念：如果一个类定义在另一个类的内部，这个内部的类就叫做内部类。注意此时的内部类是一个独立的类，它不属于任何类，不属于外部类，外部的类对内部类没有任何优越的访问权限，不能通过外部类的对象去调用内部类。

**注意**：内部类就是外部类的友元类。注意友元类的定义，内部类可以通过外部类的对象参数来访问外部类中的所有成员。但是外部类不是内部类的友元。

特性：
1. 内部类可以定义在外部类的public、protected、private都是可以的。
2. 注意内部类可以直接访问外部类中的static、枚举成员，不需要外部类的对象/类名。
3. sizeof(外部类)=外部类对象大小，和内部类没有任何关系。

```cpp
class A
{
private:
	static int k;
	int h;
public:
	class B
	{
	public:
		void foo(const A& a)
		{
			cout << k << endl;//OK
			cout << a.h << endl;//OK
		}
	};
};
int A::k = 1;
int main()
{
	A::B b;//使用内部类去初始化一个对象
	b.foo(A());
	return 0;
}
```

访问限定符对内部类的修饰和对类的成员变量和成员函数的作用是一样的，外部类私有的内部类是无法在外部类的外部被使用的，只能使用外部类的成员函数去使用内部类。

## 再次理解封装

C++是基于面向对象的程序，面向对象有三大特性：继承、封装、多态。

C++通过类，将一个对象的属性与行为结合在一起，使其更符合人们对于一件事物的认知，将属于该对象的所有东西打包在一起；通过访问限定符选择性的将其部分功能开放出来与其他对象进行交互，而对于对象内部的一些实现细节，外部用户不需要知道，知道了有些情况下也没用，反而增加了使用或者维护的难度，让整个事情复杂化。

下面举个例子来让大家更好的理解封装性带来的好处，比如：乘火车出行。

![image-20220720201401672](https://pic.xinsong.xyz/img/202207202014806.png)

无规矩不成方圆，正是因为火车站大家都默默得遵守规矩，大家才能出行更安全便捷，来看看火车站的程序：

售票系统：出售火车票，并提供选座服务，用户凭借票进入对号入座。

工作人员：售票、咨询服务、安检、卫生。

火车：运送乘客到目的地。

![image-20220720201839544](https://pic.xinsong.xyz/img/202207202018609.png)

在整个系统中，每个部分、工作人员、乘客必须配合起来，才能让出行有条不紊，乘客不需要知道售票系统的运作方式，不需要知道火车的构造，按照提示和规范操作即可。

想下，如果是没有任何管理的开放性站台呢？ 火车站没有围墙，站内火车管理调度也是随意，乘车也没有规矩，比如：

![image-20220720202222895](https://pic.xinsong.xyz/img/202207202022954.png)

那么这样没有了外界的约束，没有了规矩，那又怎么能保证每个人都是有良好素质的呢？那么我们出行的安全、准时、便捷都会被影响。

## 再次理解面向对象

概念：面向对象程序设计(英语：Object-oriented programming,缩写：OOP)是种具有对象概念的编程典范，同时也是一种程序开发的抽象方针。它可能包含数据、特性、代码与方法。对象则指的是类(css)的实例。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性，对象里的程序可以访问及经常修改对象相关连的数据。在面向对象程序编程里，计算机程序会被设计成彼此相关的对象。

**面向对象技术简介**

1. 对象：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。
2. 类：类是一个模板，它描述一类对象的行为和状态。
3. 方法：方法就是行为，一个类可以有很多方法。逻辑运算、数据修改以及所有动作都是在方法中完成的。
4. 实例变量：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。

下图中**男孩（boy）**、**女孩（girl）**为**类（class）**，而具体的每个人为该类的**对象（object）**：

1. ![img](https://pic.xinsong.xyz/img/202207202053676.jpeg)

上面的简介或许不够直观，面向对象具体是什么呢？和面向过程有何区别？我们以外卖小哥送餐为例子。

现在我们点外卖只需要打开APP，进行点餐操作在家中等待就可以了。

那么商家就会开始制作，外卖小哥接单后就会开始前往商家取餐，最终送达到我们手中。

在手机上我们可以看到外卖小哥的送餐轨迹和商家的制作进度，这些都是三者之间的信息传递而达到的，手机上展现的是模拟现实。

外卖小哥、商家、用户都对应着不同的类。而每一个商家、外卖小哥、用户都是相应类实例化出的对象，通过它们之间的交互共同作用构成外卖系统。



面向对象旨在关注每一个对象，而不是某一个过程，**传统的面向过程**映射的是送餐的过程、点餐的过程以及制作的过程，而面向对象是通过对象，模拟对象的行为，如商家要制作餐点，用户要点餐，外卖小哥要送餐。

![image-20220720202411884](https://pic.xinsong.xyz/img/202207202024930.png)

总之，面向对象就是对现实世界的模拟，通过实例化出对象，模拟对象的行为，达到我们的目的。
