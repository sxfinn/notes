# 2022-05-20-

### 摘要
> 面向过程和面向对象初步认识
>
> 类的引入
>
> 类的定义
>
> 类的作用域
>
> 类的实例化
>
> 类的访问限定符及封装
>
> 类的对象大小计算
>
> 类的成员函数的this指针

### 总结
> 

目录
---
[TOC]

------

## 面向过程和面向对象初步认识

> C语言是**面向过程的**，关注的是过程，分析出求解问题的步骤，通过函数调用逐步解决问题。
>
> C++是**基于面向对象的**，关注的是对象，将一件事拆分成不同的对象，靠对象之间的交互完成。

以外卖点餐系统为例：

外卖点餐有具体步骤有顾客点餐，商家做餐，外卖员送餐，C语言关注的是点餐的各个步骤，即点餐、做餐和送餐的过程，而C++则是关注顾客、商家、外卖员这三个对象，依托三个对象之间的交互来完成点餐的过程。



## 类的引入

C语言中，结构体内只能定义变量，而在C++中结构体内不仅可以定义变量，还可以定义函数。

```cpp
struct Student
{
	void SetStudentInfo(const char* name, const char* gender, int age)
	{
		strcpy(_name, name);
		strcpy(_gender, gender);
		_age = age;
	}
	void PrintStudentInfo()
	{
		cout << _name << " " << _gender << " " << _age << endl;
	}
	char _name[20];
	char _gender[3];
	int _age;
};
int main()
{
	Student s;
	s.SetStudentInfo("songxin", "male", 20);
	s.PrintStudentInfo();
	return 0;
}
```

**struct**是C语言中定义结构体的关键字，在C++中更倾向使用**class**代替

## 类的定义

```cpp
class classname
{
	//函数
	//成员
};//注意这里有分号
```

**class**为定义类的关键字，**classname**为类的名称。**{}中为类的主体**，注意类的定义后面要加**分号**。

类中的元素称为**类的成员**：类中的数据称为类的属性或者成员变量; 类中的函数称为类的方法或者成员函数。

**类的两种定义方式：**

1. 声明和定义都放在类体中，需要注意的是：成员函数如果在类体中定义，则默认会给编译器建议使此函数成为内联。

![image-20220520090145946](https://pic.xinsong.xyz/img/202205200901166.png)

2. 声明和定义分离

![image-20220520090703141](https://pic.xinsong.xyz/img/202205200907238.png)

一般来说我们更青睐第二种方式，即使这样写会麻烦一些。

## 类的访问限定符及封装

C语言中的结构体并没有访问限定符和封装的概念，我们可以对结构体中的内容随意访问并且修改，这就很考验程序员的素养，人人都可以修改结构体的数据，这就会带来一些不可预知的问题。

无规矩不成方圆，我们无法去赌每一个程序员都是能按照规范编写程式，因此C++引入了访问限定符来限制我们对类中成员的权限。

### 访问限定符

---

C++实现封装的方式：用类将对象的属性与方法结合在一块，让对象更加完善，**通过访问权限选择性的将其接口提供给外部的用户使用**。

![image-20220520091450037](https://pic.xinsong.xyz/img/202205200914103.png)

访问限定符如上图，有三种权限分别设置为公有、保护、私有。

**访问限定符说明**

* public修饰的成员在类外可以直接被访问
* protected和private修饰的成员在类外不能直接被访问(此处protected和private是类似的)
* **访问权限作用域从该访问限定符出现的位置开始直到下一个访问限定符出现时为止**
* class的默认访问权限为private，struct为public(因为struct要兼容C)

既然被保护的成员不能被外部通过对象所直接访问，那么在成员函数中呢？

```cpp
class Time
{
public:
	Time(int hour = 0, int minute = 0, int second = 0)
		:
		_hour(hour),
		_minute(minute),
		_second(second)
	{}
	Time(Time& t)
	{
		_hour = t._hour;//通过另一个对象名直接访问了私有成员函数
		_minute = t._minute;
		_second = t._second;
	}
private:
	int _hour;
	int _minute;
	int _second;
};
```

有两个解释方法：

1. Time是成员函数属于类，而访问限定符限制的是外部，在类域中可以随意访问。
2. 相同class的实例化出的各个对象互为友元。

**注意：访问限定符仅在编译时有用，当数据映射到内存后，没有任何访问限定符上的区别**。

来看看下面这个问题

**C++中struct和class的区别是什么？**

C++需要**兼容C语言**，所以C++中struct可以当成结构体去使用。另外C++中struct还可以用来定义类。和class是定义类是一样的，区别是struct的成员默认访问方式是public，class是的成员默认访问方式是private。

### 封装

---

面向对象三大特性：**封装、继承、多态**。

在类和对象阶段，我们只研究类的封装特性，那什么是封装呢？

封装：将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行交互。

**封装本质上是一种管理**：我们如何管理兵马俑呢？比如如果什么都不管，兵马俑就被随意破坏了。那么我们首先建了一座房子把兵马俑给**封装**起来。但是我们目的不是全封装起来，不让别人看。所以我们开放了售票通道，可以买票突破封装在合理的监管机制下进去参观。类也是一样，我们使用类数据和方法都封装到一下。不想给别人看到的，我们使用protected/private把成员封装起来。开放一些共有的成员函数对成员合理的访问。所以封装本质是管理。

### 类的作用域

---

类新定义了一个作用域，类的所以成员都在类的作用域中。在类外定义成员，需要使用::作用域解析符来指明成员属于哪个类。

```cpp
class Person
{
public:
	void PrintPersonInfo();
private:
	char _name[20];
	char _gender[3];
	int _age;
};
//类外定义成员函数需要加上::作用域解析符
void Person::PrintPersonInfo()
{
	cout << _name << endl;
	cout << _gender << endl;
	cout << _age << endl;
}
```

**总之，封装有利于管理类的对象，让对象的处理操作更加统一，对于一些我们不想给外界直接访问的成员可以设置为私有，对于需要被外部使用的成员设置为公有，这样的封装设计让我们的程式更加规范安全。**

## 类的实例化

> 用类去创建对象的过程，称为类的实例化。

1. 类形象的说就是一个模具，我们可以使用设计好的模具去制作出实体对象。
2. 类只声明了类有哪些成员，而并没有为成员分配内存空间。
3. 一个类可以实例化出多个对象，实例化出的对象占用实际的物理空间，存储类成员变量。
4. 做个比方。类实例化出对象就像现实中使用建筑设计图建造出房子，类就像是设计图，只设计出需要什么东西，但是并没有实体的建筑存在，同样类也只是一个设计，实例化出的对象才能实际存储数据，占用物理空间。

![image-20220520095502037](https://pic.xinsong.xyz/img/202205200955125.png)



![image-20220520095525280](https://pic.xinsong.xyz/img/202205200955353.png)



## 类对象模型

### 计算类对象的大小

---

```cpp
class Person
{
public:
	void PrintPersonInfo();
private:
	int _age;
};
int main()
{
	Person p;
	cout << sizeof(Person) << endl;
    cout << sizeof(p) << endl;
	return 0;
}
```

输出：

> 4
>
> 4

这里使用sizeof计算Person类的大小和Person类定义出来的对象大小是一样的。

### 类对象的存储方式

---

* **如果对象中包含类中的所有成员**

![image-20220520101824349](https://pic.xinsong.xyz/img/202205201018389.png)

缺陷：每个对象中成员变量是不同的，但是调用同一份函数，如果按照此种方式存储，当一个类创建多个对象时，每个对象中都会保存一份代码，相同代码保存多次，浪费空间。那么如何解决呢？

* **只保存成员变量，成员函数指令放在公共的代码段**

![image-20220520101952381](https://pic.xinsong.xyz/img/202205201019414.png)

这里需要给大小 说说内存中的分区，C++程序的内存格局通常分为四个区：**静态区(static area)，代码区(code area)，栈区(stack area)，堆区(heap area)(即自由存储区)**。静态区存放全局变量，静态数据和常量；所有**类成员函数和非成员函数代码存放在代码区**；为运行函数而分配的局部变量、函数参数、返回数据、返回地址等存放在栈区；余下的空间都被称为堆区。

根据这个解释，我们可以得知在类的定义时，类成员函数是被放在代码区，而类的静态成员变量是存储在静态区的，即实例化的对象并不包括静态变量的创建，因而它是属于类的。对于非静态成员变量，我们是在类的实例化过程中(构造对象)才在栈区或者堆区为其分配内存，是为每个对象生成一个拷贝，所以它是属于对象的。

那么肯定是第二种存储方式更节省空间，那么实际中到底是哪种存储方式呢？

依然使用刚刚的代码，简单变形一下

```cpp
//即有成员变量又有成员函数
class Person1
{
public:
	void PrintPersonInfo();
private:
	int _age;
};
//仅有成员变量
class Person2
{
private:
	int _age;
};
//空类
class Person3
{};
int main()
{
	cout << sizeof(Person1) << endl;
   	cout << sizeof(Person2) << endl;
    cout << sizeof(Person3) << endl;
	return 0;
}
```

输出：

> 4
>
> 4
>
> 1

很显然，我们计算对象的大小和是否含有成员函数无关（也就是说**成员函数存储在代码区**），对象中也不存放成员函数的指针。

**结论：一个类的大小，实际就是该类中”成员变量”大小之和，当然也要进行内存对齐，注意空类的大小，空类比较特殊，编译器给了空类一个字节来唯一标识这个类。**

**注：这里的成员变量之和并不是简单的字节数相加，而是还要遵循内存对齐规则。**

### 结构体内存对齐规则

---

> 1. 第一个成员在与结构体偏移量为0的地址处。
> 2. 其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。
>
> ​      注意：对齐数 = 编译器默认的一个对齐数与该成员大小的较小值。
> ​      VS中默认的对齐数为8;
>
> 3. 结构体总大小为：最大对齐数（所有变量类型最大者与默认对齐参数取最小）的整数倍。
> 4. 如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍。

这里的规则和C语言的规则是一样的，就不再展开讲了。

## this指针

---

```cpp
class Date
{
public:
	void Display()
	{
		cout << _year << "-" << _month << "-" << _day << endl;
	}
	void SetDate(int year, int month, int day)
	{
		_year = year;
		_month = month;
		_day = day;
	}
private:
	int _year; // 年
	int _month; // 月
	int _day; // 日
};
int main()
{
	Date d1, d2;
	d1.SetDate(2018, 5, 1);
	d2.SetDate(2018, 7, 1);
	d1.Display();
	d2.Display();
	return 0;
}
```

对于上述程序，d1和d2各自有不同的内存空间，可我们的成员函数SetDate中却并没有指定要对哪一个对象的成员进行操作，那么当d1调用时函数是如何知道操作的对象是哪一个呢？

>C++中通过引入this指针解决该问题，即：C++编译器给每个**“非静态的成员函数“**增加了一个隐藏的指针参数，让该指针指向当前对象(函数运行时调用该函数的对象)，在函数体中所有成员变量的操作，都是通过该指针去访问。只不过所有的操作对用户是透明的，即用户不需要来传递，编译器自动完成。

**注：实参形参中不能显式地去写this指针。**

因此程序还可以这样写：

```cpp
class Date
{
public:
	void Display()
	{
		cout << this->_year << "-" << this->_month << "-" << this->_day << endl;
	}
	void SetDate(int year, int month, int day)
	{
		this->_year = year;
		this->_month = month;
		this->_day = day;
	}
private:
	int _year; // 年
	int _month; // 月
	int _day; // 日
};
int main()
{
	Date d1, d2;
	d1.SetDate(2018, 5, 1);
	d2.SetDate(2018, 7, 1);
	d1.Display();
	d2.Display();
	return 0;
}
```

实际上我们不写this->成员，比那一起也会这样给我们处理。

### this指针的特性

---

1. this指针的类型：TypeOfClass* const，this指针在函数体内不可修改。
2. 只能在“成员函数”的内部使用。
3. **this指针本质上其实是一个成员函数的形参**，是对象调用成员函数时，将对象地址作为实参传递给this形参，对象中并不存储this指针。
4. **this指针是成员函数第一个隐含的指针形参**，一般情况由编译器通过ecx寄存器自动传递，不需要用户传递。

如下两种写法并无差别

![image-20220520104726277](https://pic.xinsong.xyz/img/202205201047337.png)

### 关于this指针

---

**this指针的存储位置在哪里？**

临时变量都是存储在栈上的，因此this指针作为形参，存储在栈区。

**this指针可以为空指针吗？**

```cpp
class A
{
public:
	void PrintA()
	{
		cout << _a << endl;
	}
	void Show()
	{
		cout << "Show()" << endl;
	}
private:
	int _a;
};
int main()
{
	A* p = nullptr;
    p->Show();
    p->PrintA();
}
```

要知道0地址处我们是没有访问权限的，若非法访问程序会崩溃。

这里的程序其实Show是可以正常调用，而**PrintA**是无法正常运行的。

来看看**PrintA函数体**的汇编指令（部分）

![image-20220520135806624](https://pic.xinsong.xyz/img/202205201358681.png)

首先**Show**可以正常调用，说明并不是p为空指针了就无法通过p调用函数了，调用函数访问的是函数的地址，而虽然它们都是成员函数，但是它们都存储在公共代码区，并不是在0地址处去访问函数，所以调用函数并没有问题，问题出在PrintA中的 `cout << _a << endl;`语句访问了_a成员变量，而p又是指向0地址处，因此就相当于访问了0地址处的数据，因此程序崩溃。

**this指针**可以为空指针，但切忌**通过nullptr去访问指向的数据**。

