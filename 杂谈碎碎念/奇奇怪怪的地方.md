## 一些奇怪的地方

不知是我菜还是有bug，有些地方始终想不明白，于是在这里写下，有知道的朋友请务必提示我。



### 内联函数在未被编译器采用建议情况

内联函数声明和定义分离，一定会发生链接错误，这一点可以保证是无误的。可是如果我们执意内联，编译器却不听话，我就产生了如下疑惑：

奇怪，这里的内联函数函数体我写成了递归，因此编译器并没有将它当做一个内联函数，而是按照普通函数去编译，于是便有了地址，有了地址理应说可以被链接到了，也就是可以被其他源文件所使用，嘿，可是不行，我大胆猜测这里是因为使用的地方也声明了f函数是内联的，因此链接不到可以理解！

到这里我还不是很懵，于是我又写了一个函数在func.cpp中，并在此函数体内调用f函数，欸，就能正常编译了！那说明不是声明的问题啊？？？难受。

不在test函数中调用f函数，又编译不过了，确实不太懂，也放弃纠结于此了~

难道是因为调用而让函数地址暴露了出来？？？我也不知道我在说什么胡话

```c
//func.h文件
#pragma once
#include<iostream>
using namespace std;
inline void f(int i);

//func.cpp文件
#include"test.h"
void f(int i)//并不会听从建议视作内联
{
	cout << "func" << endl;
	if (i > 10)
		return;
	f(i + 1);
}
void test()
{
	f(1);//有这里就正常通过，否则通不过
	cout << " ";
}

//main.cpp文件
#include"test.h"
int main()
{
	f(1);
	return 0;
}
```

